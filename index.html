<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>SanYuan</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="SanYuan">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="SanYuan">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="SanYuan">
  
    <link rel="alternate" href="/atom.xml" title="SanYuan" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">SanYuan</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Zoeken"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Python-自定义函数的特殊属性" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/13/Python-自定义函数的特殊属性/" class="article-date">
  <time datetime="2016-12-13T09:26:53.000Z" itemprop="datePublished">2016-12-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/13/Python-自定义函数的特殊属性/">Python 自定义函数的特殊属性</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Python 中通过函数定义所创建的用户自定义函数对象均具有一些特殊属性，需要注意的是这里介绍的是自定义函数（function类型）的特殊属性，而非方法（method 类型）的特殊属性，函数和方法的特熟属性以及默认的返回值可能不尽相同。</p>
<p>对于大多数特殊属性，可以通过下面这个例子示范一下：</p>
<p>class Test():</p>
<pre><code>def func(self, v = &apos;dog&apos;):
    &apos;&apos;&apos;这里演示一个闭包函数&apos;&apos;&apos;

    name = &apos;dobi&apos;
    def inn_func(age = 1):
        print(name, v, age)

    return inn_func
</code></pre><p>test = Test()<br>clsfunc = test.func()</p>
<p>首先看一下方法与函数的区别：实例的函数为bound method，而类的函数以及闭包均为function，需要强调的是 Python 2.x 中类的函数为unbound method，这点与Python 3.x 有所不同，本文则基于 Python 3.51 整理。</p>
<p>print(Test.func)</p>
<h1 id=""><a href="#" class="headerlink" title=""></a><function test.func="" at="" 0x0000020f0766e268=""></function></h1><p>print(test.func)</p>
<h1 id="-1"><a href="#-1" class="headerlink" title=""></a><bound method="" test.func="" of="" <__main__.test="" object="" at="" 0x0000020f077e5da0="">&gt;</bound></h1><p>print(clsfunc)</p>
<h1 id="-2"><a href="#-2" class="headerlink" title=""></a><function test.func.<locals="">.inn_func at 0x0000020F071D7F28&gt;</function></h1><p><strong>doc</strong></p>
<p>可写；用于获取函数的文档说明，如果没有，则返回 None。</p>
<p>print(‘Test.func.<strong>doc</strong>:’, Test.func.<strong>doc</strong>)</p>
<h1 id="Test-func-doc-这里演示一个闭包函数"><a href="#Test-func-doc-这里演示一个闭包函数" class="headerlink" title="Test.func.doc: 这里演示一个闭包函数"></a>Test.func.<strong>doc</strong>: 这里演示一个闭包函数</h1><p>Test.func.<strong>doc</strong> = ‘ddd’  #注意，这里是 Test,不能是 test<br>print(‘Test.func.<strong>doc</strong>:’, Test.func.<strong>doc</strong>)</p>
<h1 id="Test-func-doc-ddd"><a href="#Test-func-doc-ddd" class="headerlink" title="Test.func.doc: ddd"></a>Test.func.<strong>doc</strong>: ddd</h1><p><strong>name</strong></p>
<p>可写；获取函数的名称。</p>
<p>print(‘Test.func.<strong>name</strong>:’, Test.func.<strong>name</strong>)</p>
<h1 id="Test-func-name-func"><a href="#Test-func-name-func" class="headerlink" title="Test.func.name: func"></a>Test.func.<strong>name</strong>: func</h1><p>Test.func.<strong>name</strong> = ‘pet’<br>print(‘Test.func.<strong>name</strong>:’, Test.func.<strong>name</strong>)</p>
<h1 id="Test-func-name-pet"><a href="#Test-func-name-pet" class="headerlink" title="Test.func.name: pet"></a>Test.func.<strong>name</strong>: pet</h1><p><strong>qualname</strong></p>
<p>可写；获取函数的qualname：点示法显示函数名称、所在的类、模块等梯级地址。</p>
<p>print(‘Test.func.<strong>qualname</strong>:’, Test.func.<strong>qualname</strong>)</p>
<h1 id="Test-func-qualname-Test-func"><a href="#Test-func-qualname-Test-func" class="headerlink" title="Test.func.qualname: Test.func"></a>Test.func.<strong>qualname</strong>: Test.func</h1><p>Test.func.<strong>qualname</strong> = ‘path’<br>print(‘Test.func.<strong>qualname</strong>:’, Test.func.<strong>qualname</strong>)</p>
<h1 id="Test-func-qualname-path"><a href="#Test-func-qualname-path" class="headerlink" title="Test.func.qualname: path"></a>Test.func.<strong>qualname</strong>: path</h1><p><strong>module</strong></p>
<p>可写；返回函数所在的模块，如果无则返回None。</p>
<p>print(‘Test.func.<strong>module</strong>:’, Test.func.<strong>module</strong>)</p>
<h1 id="Test-func-module-main"><a href="#Test-func-module-main" class="headerlink" title="Test.func.module: main"></a>Test.func.<strong>module</strong>: <strong>main</strong></h1><p>Test.func.<strong>module</strong> = ‘a’<br>print(‘Test.func.<strong>module</strong>:’, Test.func.<strong>module</strong>)</p>
<h1 id="Test-func-module-a"><a href="#Test-func-module-a" class="headerlink" title="Test.func.module: a"></a>Test.func.<strong>module</strong>: a</h1><p><strong>defaults</strong></p>
<p>可写；以元组的形式返回函数的默认参数，如果无默认参数则返回None。</p>
<p>print(‘Test.func.<strong>defaults</strong>:’, Test.func.<strong>defaults</strong>)</p>
<h1 id="Test-func-defaults-‘dog’"><a href="#Test-func-defaults-‘dog’" class="headerlink" title="Test.func.defaults: (‘dog’,)"></a>Test.func.<strong>defaults</strong>: (‘dog’,)</h1><p>Test.func.<strong>defaults</strong> = (‘cat’,)<br>print(‘Test.func.<strong>defaults</strong>:’, Test.func.<strong>defaults</strong>)</p>
<h1 id="Test-func-defaults-‘cat’"><a href="#Test-func-defaults-‘cat’" class="headerlink" title="Test.func.defaults: (‘cat’,)"></a>Test.func.<strong>defaults</strong>: (‘cat’,)</h1><p>print(‘clsfunc.<strong>defaults</strong>:’, clsfunc.<strong>defaults</strong>)</p>
<h1 id="clsfunc-defaults-1"><a href="#clsfunc-defaults-1" class="headerlink" title="clsfunc.defaults: (1,)"></a>clsfunc.<strong>defaults</strong>: (1,)</h1><p>clsfunc.<strong>defaults</strong> = (2,)<br>print(‘clsfunc.<strong>defaults</strong>:’, clsfunc.<strong>defaults</strong>)</p>
<h1 id="clsfunc-defaults-2"><a href="#clsfunc-defaults-2" class="headerlink" title="clsfunc.defaults: (2,)"></a>clsfunc.<strong>defaults</strong>: (2,)</h1><p><strong>code</strong></p>
<p>可写；返回已编译的函数对象。</p>
<p>print(‘Test.func.<strong>code</strong>:’, Test.func.<strong>code</strong>)</p>
<h1 id="Test-func-code"><a href="#Test-func-code" class="headerlink" title="Test.func.code:"></a>Test.func.<strong>code</strong>:</h1><p>def func2():print(‘cat’)<br>Test.func.<strong>code</strong> = func2.<strong>code</strong><br>Test.func()</p>
<h1 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h1><p>print(‘Test.func.<strong>code</strong>:’, Test.func.<strong>code</strong>)</p>
<h1 id="Test-func-code-1"><a href="#Test-func-code-1" class="headerlink" title="Test.func.code:"></a>Test.func.<strong>code</strong>:</h1><p><strong>globals</strong></p>
<p>只读，以字典的形式返回函数所在的全局命名空间所定义的全局变量。</p>
<p>print(‘Test.func.<strong>globals</strong>:’, Test.func.<strong>globals</strong>)</p>
<h1 id="Test-func-globals"><a href="#Test-func-globals" class="headerlink" title="Test.func.globals: {"></a>Test.func.<strong>globals</strong>: {</h1><h1 id="‘cached‘-None"><a href="#‘cached‘-None" class="headerlink" title="‘cached‘: None,"></a>‘<strong>cached</strong>‘: None,</h1><h1 id="‘Test’"><a href="#‘Test’" class="headerlink" title="‘Test’: ,"></a>‘Test’: <class '__main__.test'="">,</class></h1><h1 id="‘builtins‘"><a href="#‘builtins‘" class="headerlink" title="‘builtins‘: ,"></a>‘<strong>builtins</strong>‘: <module 'builtins'="" (built-in)="">,</module></h1><h1 id="‘func2’"><a href="#‘func2’" class="headerlink" title="‘func2’: ,"></a>‘func2’: <function func2="" at="" 0x0000020f077d3c80="">,</function></h1><h1 id="‘spec‘-None"><a href="#‘spec‘-None" class="headerlink" title="‘spec‘: None,"></a>‘<strong>spec</strong>‘: None,</h1><h1 id="‘doc‘-None"><a href="#‘doc‘-None" class="headerlink" title="‘doc‘: None,"></a>‘<strong>doc</strong>‘: None,</h1><h1 id="‘file‘-‘D-…-a-py’"><a href="#‘file‘-‘D-…-a-py’" class="headerlink" title="‘file‘: ‘D:\…\a.py’,"></a>‘<strong>file</strong>‘: ‘D:\…\a.py’,</h1><h1 id="‘test’"><a href="#‘test’" class="headerlink" title="‘test’: ,"></a>‘test’: <__main__.test object="" at="" 0x0000020f077e5da0="">,</__main__.test></h1><h1 id="‘clsfunc’"><a href="#‘clsfunc’" class="headerlink" title="‘clsfunc’: "></a>‘clsfunc’: <function test.func.<locals="">.inn_func at 0x0000020F071D7F28&gt;,</function></h1><h1 id="‘package‘-None"><a href="#‘package‘-None" class="headerlink" title="‘package‘: None,"></a>‘<strong>package</strong>‘: None,</h1><h1 id="‘name‘-‘main‘"><a href="#‘name‘-‘main‘" class="headerlink" title="‘name‘: ‘main‘,"></a>‘<strong>name</strong>‘: ‘<strong>main</strong>‘,</h1><h1 id="‘loader‘"><a href="#‘loader‘" class="headerlink" title="‘loader‘: "></a>‘<strong>loader</strong>‘: <_frozen_importlib_external.sourcefileloader object="" at="" 0x0000020f07289828=""></_frozen_importlib_external.sourcefileloader></h1><h1 id="-3"><a href="#-3" class="headerlink" title="}"></a>}</h1><p><strong>dict</strong></p>
<p>可写；以字典的形式返回命名空间所支持的任意自定义的函数属性。</p>
<p>print(‘Test.func.<strong>dict</strong>:’, Test.func.<strong>dict</strong>)</p>
<h1 id="Test-func-dict"><a href="#Test-func-dict" class="headerlink" title="Test.func.dict: {}"></a>Test.func.<strong>dict</strong>: {}</h1><p><strong>closure</strong></p>
<p>只读；以包含cell的元组形式返回闭包所包含的自由变量。</p>
<p>print(‘Test.func.<strong>closure</strong>:’, Test.func.<strong>closure</strong>)</p>
<h1 id="None"><a href="#None" class="headerlink" title="None"></a>None</h1><p>print(‘clsfunc.<strong>closure</strong>:’, clsfunc.<strong>closure</strong>)</p>
<h1 id="clsfunc-closure"><a href="#clsfunc-closure" class="headerlink" title="clsfunc.closure: ("></a>clsfunc.<strong>closure</strong>: (</h1><h1 id="-4"><a href="#-4" class="headerlink" title=","></a><cell at="" 0x0000020f071fe708:="" str="" object="" 0x0000020f07289998="">,</cell></h1><h1 id="-5"><a href="#-5" class="headerlink" title=""></a><cell at="" 0x0000020f072b8c78:="" str="" object="" 0x0000020f0766c538=""></cell></h1><h1 id="-6"><a href="#-6" class="headerlink" title=")"></a>)</h1><p>print(‘clsfunc.<strong>closure</strong>[x]:’, clsfunc.<strong>closure</strong>[0].cell_contents, clsfunc.<strong>closure</strong>[1].cell_contents)</p>
<h1 id="clsfunc-closure-x-dobi-dog"><a href="#clsfunc-closure-x-dobi-dog" class="headerlink" title="clsfunc.closure[x]: dobi dog"></a>clsfunc.<strong>closure</strong>[x]: dobi dog</h1><p><strong>annotations</strong></p>
<p>可写；具体详见“Python 的函数注释”(<a href="https://segmentfault.com/a/1190000005173184" target="_blank" rel="external">https://segmentfault.com/a/1190000005173184</a>)</p>
<p><strong>kwdefaults</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/13/Python-自定义函数的特殊属性/" data-id="ciwnb1bfk000l56cyn27aql8j" class="article-share-link">Delen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-python实现自动备份文件夹功能" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/13/python实现自动备份文件夹功能/" class="article-date">
  <time datetime="2016-12-13T09:14:57.000Z" itemprop="datePublished">2016-12-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/13/python实现自动备份文件夹功能/">python实现自动备份文件夹功能</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>python实现自动备份文件夹功能</p>
<p>python实现的自动备份文件夹的功能，实现u盘插入后的自动备份功能，备份压缩文件以备份时间命名，实现自动删除两个月之前的备份文件。<br>网上看到在windows下通过调用命令行来进行压缩，但是我在备份多个文件夹的时候，一直是只能备份一个文件夹。so，找到了zipfile这个模块。<br>其中备份为压缩文档使用到了python中的zipfile模块，具体用法请查看官方文档。</p>
<p>#coding:utf-8<br>‘’’<br>Created on 2015年7月28日<br>功能简介：</p>
<ul>
<li>实现文件夹的自动备份，并会自动删除两个月之前的备份文件。</li>
<li>实现插入u盘后的自动备份。</li>
</ul>
<p>@author: zhuzhezhe<br>‘’’<br>import time,datetime,os,os.path,zipfile,glob<br>from zipfile import ZIP_DEFLATED<br>def backup(filepath):</p>
<pre><code>#需要备份的文件夹
from_dir = []
&apos;&apos;&apos;
with open(&apos;backup.txt&apos;,&apos;r&apos;) as file:
    for line in file:
        from_dir.append(line)
    file.close(
&apos;&apos;&apos;
#print from_dir
#这里输入你需要备份的文件夹
from_dir = [&apos;F:\code\python\test&apos;,
            &apos;F:\code\java&apos;,]
#当前备份时间
back_time = time.strftime(u&apos;%Y-%m-%d&apos;)
#目标文件夹
to_dir = filepath+u&apos;:\\backup&apos;
if not os.path.exists(to_dir):
    os.mkdir(to_dir)
    print u&apos;已新建备份目录.&apos;
os.chdir(to_dir)
#打包文件夹的名字
target = back_time+u&apos;.zip&apos;
#依次打包压缩每个文件
if not os.path.exists(target):
    zip = zipfile.ZipFile(target,&apos;a&apos;,ZIP_DEFLATED)
    for file in from_dir:
        for f in glob.glob(file+&apos;\\*&apos;): #glob生成文件夹下所有文件的列表
            zip.write(f)
    print u&apos;备份完成.&apos;
    zip.close()

#删除两个月之前的备份文件
#列出所有备份文件
os.chdir(to_dir)
list_file = os.listdir(to_dir)
#两个月之前的时间,使用timedelta表示一个时间段,可以实现时间的加减
old_time = datetime.date.today()-datetime.timedelta(2*30)
#print str(old_time)[5:7]
for lis in list_file:
    if lis[5:7] == str(old_time)[5:7]:
        os.remove(lis)
</code></pre><p>if <strong>name</strong> == ‘<strong>main</strong>‘:<br>    backup(‘F’)</p>
<pre><code>#如果插入u盘，则自动备份到u盘
if os.path.exists(&apos;G:&apos;) == True:
    backup(&apos;G&apos;)
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/13/python实现自动备份文件夹功能/" data-id="ciwnb1bg0000x56cyfgfekyri" class="article-share-link">Delen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Python-资源-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/13/Python-资源-1/" class="article-date">
  <time datetime="2016-12-13T09:02:31.000Z" itemprop="datePublished">2016-12-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/13/Python-资源-1/">Python 资源</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>环境管理</p>
<p>管理 Python 版本和环境的工具</p>
<ul>
<li>p – 非常简单的交互式 python 版本管理工具。</li>
<li>pyenv – 简单的 Python 版本管理工具。</li>
<li>Vex – 可以在虚拟环境中执行命令。</li>
<li>virtualenv – 创建独立 Python 环境的工具。</li>
<li>virtualenvwrapper– virtualenv 的一组扩展。</li>
</ul>
<p>包管理</p>
<p>管理包和依赖的工具。</p>
<ul>
<li>pip – Python 包和依赖关系管理工具。</li>
<li>pip-tools – 保证 Python 包依赖关系更新的一组工具。</li>
<li>conda – 跨平台，Python 二进制包管理工具。</li>
<li>Curdling – 管理 Python 包的命令行工具。</li>
<li>wheel – Python 分发的新标准，意在取代 eggs。</li>
</ul>
<p>包仓库</p>
<p>本地 PyPI 仓库服务和代理。</p>
<ul>
<li>warehouse – 下一代 PyPI。<br>Warehouse bandersnatch – PyPA 提供的 PyPI 镜像工具。</li>
<li>devpi – PyPI 服务和打包/测试/分发工具。</li>
<li>localshop – 本地 PyPI 服务（自定义包并且自动对 PyPI 镜像）。</li>
</ul>
<p>分发</p>
<p>打包为可执行文件以便分发。</p>
<ul>
<li>PyInstaller – 将 Python 程序转换成独立的执行文件（跨平台）。</li>
<li>dh-virtualenv – 构建并将 virtualenv 虚拟环境作为一个 Debian 包来发布。</li>
<li>Nuitka – 将脚本、模块、包编译成可执行文件或扩展模块。</li>
<li>py2app – 将 Python 脚本变为独立软件包（Mac OS X）。</li>
<li>py2exe – 将 Python 脚本变为独立软件包（Windows）。</li>
<li>pynsist – 一个用来创建 Windows 安装程序的工具，可以在安装程序中打包 Python本身。</li>
</ul>
<p>构建工具</p>
<p>将源码编译成软件。</p>
<ul>
<li>buildout – 一个构建系统，从多个组件来创建，组装和部署应用。</li>
<li>BitBake – 针对嵌入式 Linux 的类似 make 的构建工具。</li>
<li>fabricate – 对任何语言自动找到依赖关系的构建工具。</li>
<li>PlatformIO – 多平台命令行构建工具。</li>
<li>PyBuilder – 纯 Python 实现的持续化构建工具。</li>
<li>SCons – 软件构建工具。</li>
</ul>
<p>交互式解析器</p>
<p>交互式 Python 解析器。</p>
<ul>
<li>IPython – 功能丰富的工具，非常有效的使用交互式 Python。</li>
<li>bpython– 界面丰富的 Python 解析器。</li>
<li>ptpython – 高级交互式Python解析器， 构建于python-prompt-toolkit 之上。</li>
</ul>
<p>文件</p>
<p>文件管理和 MIME（多用途的网际邮件扩充协议）类型检测。</p>
<ul>
<li>imghdr – （Python 标准库）检测图片类型。</li>
<li>mimetypes – （Python 标准库）将文件名映射为 MIME 类型。</li>
<li>path.py – 对 os.path 进行封装的模块。</li>
<li>pathlib – （Python3.4+ 标准库）跨平台的、面向对象的路径操作库。</li>
<li>python-magic– 文件类型检测的第三方库 libmagic 的 Python 接口。</li>
<li>Unipath– 用面向对象的方式操作文件和目录</li>
<li>watchdog – 管理文件系统事件的 API 和 shell 工具</li>
</ul>
<p>日期和时间</p>
<p>操作日期和时间的类库。</p>
<ul>
<li>arrow– 更好的 Python 日期时间操作类库。</li>
<li>Chronyk – Python 3 的类库，用于解析手写格式的时间和日期。</li>
<li>dateutil – Python datetime 模块的扩展。</li>
<li>delorean– 解决 Python 中有关日期处理的棘手问题的库。</li>
<li>moment – 一个用来处理时间和日期的Python库。灵感来自于Moment.js。</li>
<li>PyTime – 一个简单易用的Python模块，用于通过字符串来操作日期/时间。</li>
<li>pytz – 现代以及历史版本的世界时区定义。将时区数据库引入Python。</li>
<li>when.py – 提供用户友好的函数来帮助用户进行常用的日期和时间操作。</li>
</ul>
<p>文本处理</p>
<p>用于解析和操作文本的库。</p>
<ul>
<li>通用<br>chardet – 字符编码检测器，兼容 Python2 和 Python3。<br>difflib – (Python 标准库)帮助我们进行差异化比较。<br>ftfy – 让Unicode文本更完整更连贯。<br>fuzzywuzzy – 模糊字符串匹配。<br>Levenshtein – 快速计算编辑距离以及字符串的相似度。<br>pangu.py – 在中日韩语字符和数字字母之间添加空格。<br>pyfiglet -figlet 的 Python实现。<br>shortuuid – 一个生成器库，用以生成简洁的，明白的，URL 安全的 UUID。<br>unidecode – Unicode 文本的 ASCII 转换形式 。<br>uniout – 打印可读的字符，而不是转义的字符串。<br>xpinyin – 一个用于把汉字转换为拼音的库。</li>
<li>Slug化<br>awesome-slugify – 一个 Python slug 化库，可以保持 Unicode。<br>python-slugify – Python slug 化库，可以把 unicode 转化为 ASCII。<br>unicode-slugify – 一个 slug 工具，可以生成 unicode slugs ,需要依赖 Django 。</li>
<li>解析器<br>phonenumbers – 解析，格式化，储存，验证电话号码。<br>PLY – lex 和 yacc 解析工具的 Python 实现。<br>Pygments – 通用语法高亮工具。<br>pyparsing – 生成通用解析器的框架。<br>python-nameparser – 把一个人名分解为几个独立的部分。<br>python-user-agents – 浏览器 user agent 解析器。<br>sqlparse – 一个无验证的 SQL 解析器。</li>
</ul>
<p>特殊文本格式处理</p>
<p>一些用来解析和操作特殊文本格式的库。</p>
<ul>
<li>通用<br>tablib – 一个用来处理中表格数据的模块。</li>
<li>Office<br>Marmir – 把输入的Python 数据结构转换为电子表单。<br>openpyxl – 一个用来读写 Excel 2010 xlsx/xlsm/xltx/xltm 文件的库。<br>python-docx – 读取，查询以及修改 Microsoft Word 2007/2008 docx 文件。<br>unoconv – 在 LibreOffice/OpenOffice 支持的任意文件格式之间进行转换。<br>XlsxWriter – 一个用于创建 Excel .xlsx 文件的 Python 模块。<br>xlwings – 一个使得在 Excel 中方便调用 Python 的库（反之亦然），基于 BSD 协议。<br>xlwt / xlrd – 读写 Excel 文件的数据和格式信息。<br>relatorio – 模板化OpenDocument 文件。</li>
<li>PDF<br>PDFMiner – 一个用于从PDF文档中抽取信息的工具。<br>PyPDF2 – 一个可以分割，合并和转换 PDF 页面的库。<br>ReportLab – 快速创建富文本 PDF 文档。</li>
<li>Markdown<br>Mistune – 快速并且功能齐全的纯 Python 实现的 Markdown 解析器。<br>Python-Markdown – John Gruber’s Markdown 的 Python 版实现。</li>
<li>YAML<br>PyYAML – Python 版本的 YAML 解析器。</li>
<li>CSV<br>csvkit – 用于转换和操作 CSV 的工具。</li>
<li>Archive<br>unp – 一个用来方便解包归档文件的命令行工具。</li>
</ul>
<p>自然语言处理</p>
<p>用来处理人类语言的库。</p>
<ul>
<li>NLTK – 一个先进的平台，用以构建处理人类语言数据的 Python 程序。</li>
<li>jieba – 中文分词工具。</li>
<li>langid.py – 独立的语言识别系统。</li>
<li>Pattern – Python 网络信息挖掘模块。</li>
<li>SnowNLP – 一个用来处理中文文本的库。</li>
<li>TextBlob – 为进行普通自然语言处理任务提供一致的 API。</li>
<li>TextGrocery – 一简单高效的短文本分类工具，基于 LibLinear 和 Jieba。</li>
</ul>
<p>文档</p>
<p>用以生成项目文档的库。</p>
<ul>
<li>Sphinx – Python 文档生成器。<br>awesome-sphinxdoc</li>
<li>MkDocs – 对 Markdown 友好的文档生成器。</li>
<li>pdoc – 一个可以替换Epydoc 的库，可以自动生成 Python 库的 API 文档。</li>
<li>Pycco – 文学编程（literate-programming）风格的文档生成器。</li>
</ul>
<p>配置</p>
<p>用来保存和解析配置的库。</p>
<ul>
<li>config – logging 模块作者写的分级配置模块。</li>
<li>ConfigObj – INI 文件解析器，带验证功能。</li>
<li>ConfigParser – (Python 标准库) INI 文件解析器。</li>
<li>profig – 通过多种格式进行配置，具有数值转换功能。</li>
<li>python-decouple – 将设置和代码完全隔离。</li>
</ul>
<p>命令行工具</p>
<p>用于创建命令行程序的库。</p>
<ul>
<li>命令行程序开发<br>cement – Python 的命令行程序框架。<br>click – 一个通过组合的方式来创建精美命令行界面的包。<br>cliff – 一个用于创建命令行程序的框架，可以创建具有多层命令的命令行程序。<br>clint – Python 命令行程序工具。<br>colorama – 跨平台彩色终端文本。<br>docopt – Python 风格的命令行参数解析器。<br>Gooey – 一条命令，将命令行程序变成一个 GUI 程序。<br>python-prompt-toolkit – 一个用于构建强大的交互式命令行程序的库。</li>
<li>生产力工具<br>aws-cli – Amazon Web Services 的通用命令行界面。<br>bashplotlib – 在终端中进行基本绘图。<br>caniusepython3 – 判断是哪个项目妨碍你你移植到 Python 3。<br>cookiecutter – 从 cookiecutters（项目模板）创建项目的一个命令行工具。<br>doitlive – 一个用来在终端中进行现场演示的工具。<br>howdoi – 通过命令行获取即时的编程问题解答。<br>httpie – 一个命令行HTTP 客户端，cURL 的替代品，易用性更好。<br>PathPicker – 从bash输出中选出文件。<br>percol – 向UNIX shell 传统管道概念中加入交互式选择功能。<br>SAWS – 一个加强版的 AWS 命令行。<br>thefuck – 修正你之前的命令行指令。<br>mycli – 一个 MySQL 命令行客户端，具有自动补全和语法高亮功能。<br>pgcli – Postgres 命令行工具，具有自动补全和语法高亮功能。</li>
</ul>
<p>下载器</p>
<p>用来进行下载的库.</p>
<ul>
<li>s3cmd – 一个用来管理Amazon S3 和 CloudFront 的命令行工具。</li>
<li>s4cmd – 超级 S3 命令行工具，性能更加强劲。</li>
<li>you-get – 一个 YouTube/Youku/Niconico 视频下载器，使用 Python3 编写。</li>
<li>youtube-dl – 一个小巧的命令行程序，用来下载 YouTube 视频。</li>
</ul>
<p>图像处理</p>
<p>用来操作图像的库.</p>
<ul>
<li>pillow – Pillow 是一个更加易用版的 PIL。</li>
<li>hmap – 图像直方图映射。</li>
<li>imgSeek – 一个使用视觉相似性搜索一组图片集合的项目。</li>
<li>nude.py – 裸体检测。</li>
<li>pyBarcode – 不借助 PIL 库在 Python 程序中生成条形码。</li>
<li>pygram – 类似 Instagram 的图像滤镜。</li>
<li>python-qrcode – 一个纯 Python 实现的二维码生成器。</li>
<li>Quads – 基于四叉树的计算机艺术。</li>
<li>scikit-image – 一个用于（科学）图像处理的 Python 库。</li>
<li>thumbor – 一个小型图像服务，具有剪裁，尺寸重设和翻转功能。</li>
<li>wand – MagickWand的Python 绑定。MagickWand 是 ImageMagick的 C API 。</li>
</ul>
<p>OCR</p>
<p>光学字符识别库。</p>
<ul>
<li>pyocr – Tesseract 和 Cuneiform 的一个封装(wrapper)。</li>
<li>pytesseract – Google Tesseract OCR 的另一个封装(wrapper)。</li>
<li>python-tesseract – Google Tesseract OCR 的一个包装类。</li>
</ul>
<p>音频</p>
<p>用来操作音频的库</p>
<ul>
<li>audiolazy -Python 的数字信号处理包。</li>
<li>audioread – 交叉库 (GStreamer + Core Audio + MAD + FFmpeg) 音频解码。</li>
<li>beets – 一个音乐库管理工具及 MusicBrainz 标签添加工具</li>
<li>dejavu – 音频指纹提取和识别</li>
<li>django-elastic-transcoder – Django + Amazon Elastic Transcoder。</li>
<li>eyeD3 – 一个用来操作音频文件的工具，具体来讲就是包含 ID3 元信息的 MP3 文件。</li>
<li>id3reader – 一个用来读取 MP3 元数据的 Python 模块。</li>
<li>m3u8 – 一个用来解析 m3u8 文件的模块。</li>
<li>mutagen – 一个用来处理音频元数据的 Python 模块。</li>
<li>pydub – 通过简单、简洁的高层接口来操作音频文件。</li>
<li>pyechonest – Echo Nest API 的 Python 客户端</li>
<li>talkbox – 一个用来处理演讲/信号的 Python 库</li>
<li>TimeSide – 开源 web 音频处理框架。</li>
<li>tinytag – 一个用来读取MP3, OGG, FLAC 以及 Wave 文件音乐元数据的库。</li>
<li>mingus – 一个高级音乐理论和曲谱包，支持 MIDI 文件和回放功能。</li>
</ul>
<p>Video</p>
<p>用来操作视频和GIF的库。</p>
<ul>
<li>moviepy – 一个用来进行基于脚本的视频编辑模块，适用于多种格式，包括动图 GIFs。</li>
<li>scikit-video – SciPy 视频处理常用程序。</li>
</ul>
<p>地理位置</p>
<p>地理编码地址以及用来处理经纬度的库。</p>
<ul>
<li>GeoDjango – 世界级地理图形 web 框架。</li>
<li>GeoIP – MaxMind GeoIP Legacy 数据库的 Python API。</li>
<li>geojson – GeoJSON 的 Python 绑定及工具。</li>
<li>geopy – Python 地址编码工具箱。</li>
<li>pygeoip – 纯 Python GeoIP API。</li>
<li>django-countries – 一个 Django 应用程序，提供用于表格的国家选择功能，国旗图标静态文件以及模型中的国家字段。</li>
</ul>
<p>HTTP</p>
<p>使用HTTP的库。</p>
<ul>
<li>requests – 人性化的HTTP请求库。</li>
<li>grequests – requests 库 + gevent ，用于异步 HTTP 请求.</li>
<li>httplib2 – 全面的 HTTP 客户端库。</li>
<li>treq – 类似 requests 的Python API 构建于 Twisted HTTP 客户端之上。</li>
<li>urllib3 – 一个具有线程安全连接池，支持文件 post，清晰友好的 HTTP 库。</li>
</ul>
<p>数据库</p>
<p>Python实现的数据库。</p>
<ul>
<li>pickleDB – 一个简单，轻量级键值储存数据库。</li>
<li>PipelineDB – 流式 SQL 数据库。</li>
<li>TinyDB – 一个微型的，面向文档型数据库。</li>
<li>ZODB – 一个 Python 原生对象数据库。一个键值和对象图数据库。</li>
</ul>
<p>数据库驱动</p>
<p>用来连接和操作数据库的库。</p>
<ul>
<li>MySQL – awesome-mysql系列<br>mysql-python – Python 的 MySQL 数据库连接器。<br>mysqlclient – mysql-python 分支，支持 Python 3。<br>oursql – 一个更好的 MySQL 连接器，支持原生预编译指令和 BLOBs.<br>PyMySQL – 纯 Python MySQL 驱动，兼容 mysql-python。</li>
<li>PostgreSQL<br>psycopg2 – Python 中最流行的 PostgreSQL 适配器。<br>queries – psycopg2 库的封装，用来和 PostgreSQL 进行交互。<br>txpostgres – 基于 Twisted 的异步 PostgreSQL 驱动。</li>
<li>其他关系型数据库<br>apsw – 另一个 Python SQLite封装。<br>dataset – 在数据库中存储Python字典 – 可以协同SQLite，MySQL，和 PostgreSQL工作。<br>pymssql– 一个简单的Microsoft SQL Server数据库接口。</li>
<li>NoSQL 数据库<br>cassandra-python-driver – Cassandra 的 Python 驱动。<br>HappyBase – 一个为 Apache HBase 设计的，对开发者友好的库。<br>Plyvel – 一个快速且功能丰富的 LevelDB 的 Python 接口。<br>py2neo – Neo4j restful 接口的Python 封装客户端。<br>pycassa – Cassandra 的 Python Thrift 驱动。<br>PyMongo – MongoDB 的官方 Python 客户端。<br>redis-py – Redis 的 Python 客户端。<br>telephus – 基于 Twisted 的 Cassandra 客户端。<br>txRedis – 基于 Twisted 的 Redis 客户端。</li>
</ul>
<p>ORM</p>
<p>实现对象关系映射或数据映射技术的库。</p>
<ul>
<li>关系型数据库<br>Django Models – Django 的一部分。<br>SQLAlchemy – Python SQL 工具以及对象关系映射工具。<br>awesome-sqlalchemy系列<br>Peewee – 一个小巧，富有表达力的 ORM。<br>PonyORM – 提供面向生成器的 SQL 接口的 ORM。<br>python-sql – 编写 Python 风格的 SQL 查询。</li>
<li>NoSQL 数据库<br>django-mongodb-engine – Django MongoDB 后端。<br>PynamoDB – Amazon DynamoDB 的一个 Python 风格接口。<br>flywheel – Amazon DynamoDB 的对象映射工具。<br>MongoEngine – 一个Python 对象文档映射工具，用于 MongoDB。<br>hot-redis – 为 Redis 提供 Python 丰富的数据类型。<br>redisco – 一个 Python 库，提供可以持续存在在 Redis 中的简单模型和容器。</li>
<li>其他<br>butterdb – Google Drive 电子表格的 Python ORM。</li>
</ul>
<p>Web 框架</p>
<p>全栈 web 框架。</p>
<ul>
<li>Django – Python 界最流行的 web 框架。<br>awesome-django系列</li>
<li>Flask – 一个 Python 微型框架。<br>awesome-flask系列</li>
<li>Pyramid – 一个小巧，快速，接地气的开源Python web 框架。<br>awesome-pyramid系列</li>
<li>Bottle – 一个快速小巧，轻量级的 WSGI 微型 web 框架。</li>
<li>CherryPy – 一个极简的 Python web 框架，服从 HTTP/1.1 协议且具有WSGI 线程池。</li>
<li>TurboGears – 一个可以扩展为全栈解决方案的微型框架。</li>
<li>web.py – 一个 Python 的 web 框架，既简单，又强大。</li>
<li>web2py – 一个全栈 web 框架和平台，专注于简单易用。</li>
<li>Tornado – 一个web 框架和异步网络库。</li>
</ul>
<p>权限</p>
<p>允许或拒绝用户访问数据或功能的库。</p>
<ul>
<li>Carteblanche – Module to align code with thoughts of users and designers. Also magically handles navigation and permissions.</li>
<li>django-guardian – Django 1.2+ 实现了单个对象权限。</li>
<li>django-rules – 一个小巧但是强大的应用，提供对象级别的权限管理，且不需要使用数据库。</li>
</ul>
<p>CMS</p>
<p>内容管理系统</p>
<ul>
<li>django-cms – 一个开源的，企业级 CMS，基于 Django。</li>
<li>djedi-cms – 一个轻量级但却非常强大的 Django CMS ，考虑到了插件，内联编辑以及性能。</li>
<li>FeinCMS – 基于 Django 构建的最先进的内容管理系统之一。</li>
<li>Kotti – 一个高级的，Python 范的 web 应用框架，基于 Pyramid 构建。</li>
<li>Mezzanine – 一个强大的，持续的，灵活的内容管理平台。</li>
<li>Opps – 一个为杂志，报纸网站以及大流量门户网站设计的 CMS 平台，基于 Django。</li>
<li>Plone – 一个构建于开源应用服务器 Zope 之上的 CMS。</li>
<li>Quokka – 灵活，可扩展的小型 CMS，基于 Flask 和 MongoDB。</li>
<li>Wagtail – 一个 Django 内容管理系统。</li>
<li>Widgy – 最新的 CMS 框架，基于 Django。</li>
</ul>
<p>电子商务</p>
<p>用于电子商务以及支付的框架和库。</p>
<ul>
<li>django-oscar – 一个用于 Django 的开源的电子商务框架。</li>
<li>django-shop – 一个基于 Django 的店铺系统。</li>
<li>Cartridge – 一个基于 Mezzanine 构建的购物车应用。</li>
<li>shoop – 一个基于 Django 的开源电子商务平台。</li>
<li>alipay – 非官方的 Python 支付宝 API。</li>
<li>merchant – 一个可以接收来自多种支付平台支付的 Django 应用。</li>
<li>money – 货币类库with optional CLDR-backed locale-aware formatting and an extensible currency exchange solution.</li>
<li>python-currencies – 显示货币格式以及它的数值。</li>
</ul>
<p>RESTful API</p>
<p>用来开发RESTful APIs的库</p>
<ul>
<li>Django<br>django-rest-framework – 一个强大灵活的工具，用来构建 web API。<br>django-tastypie – 为Django 应用开发API。<br>django-formapi – 为 Django 的表单验证，创建 JSON APIs 。</li>
<li>Flask<br>flask-api – 为 flask 开发的，可浏览 Web APIs 。<br>flask-restful – 为 flask 快速创建REST APIs 。<br>flask-restless – 为 SQLAlchemy 定义的数据库模型创建 RESTful APIs 。<br>flask-api-utils – 为 Flask 处理 API 表示和验证。<br>eve – REST API 框架，由 Flask, MongoDB 等驱动。</li>
<li>Pyramid<br>cornice – 一个Pyramid 的 REST 框架 。</li>
<li>与框架无关的<br>falcon – 一个用来建立云 API 和 web app 后端的噶性能框架。<br>sandman – 为现存的数据库驱动系统自动创建 REST APIs 。<br>restless – 框架无关的 REST 框架 ，基于从 Tastypie 学到的知识。<br>ripozo – 快速创建 REST/HATEOAS/Hypermedia APIs。</li>
</ul>
<p>验证</p>
<p>实现验证方案的库。</p>
<ul>
<li>OAuth<br>Authomatic – 简单但是强大的框架，身份验证/授权客户端。<br>django-allauth – Django 的验证应用。<br>django-oauth-toolkit – 为 Django 用户准备的 OAuth2。<br>django-oauth2-provider – 为 Django 应用提供 OAuth2 接入。<br>Flask-OAuthlib – OAuth 1.0/a, 2.0 客户端实现，供 Flask 使用。<br>OAuthLib – 一个 OAuth 请求-签名逻辑通用、 完整的实现。<br>python-oauth2 – 一个完全测试的抽象接口。用来创建 OAuth 客户端和服务端。<br>python-social-auth – 一个设置简单的社会化验证方式。<br>rauth – OAuth 1.0/a, 2.0, 和 Ofly 的 Python 库。<br>sanction – 一个超级简单的OAuth2 客户端实现。</li>
<li>其他<br>jose – JavaScript 对象签名和加密草案的实现。<br>PyJWT – JSON Web 令牌草案 01。<br>python-jws – JSON Web 签名草案 02 的实现。<br>python-jwt – 一个用来生成和验证 JSON Web 令牌的模块。</li>
</ul>
<p>模板引擎</p>
<p>模板生成和词法解析的库和工具。</p>
<ul>
<li>Jinja2 – 一个现代的，对设计师友好的模板引擎。</li>
<li>Chameleon – 一个 HTML/XML 模板引擎。 模仿了 ZPT（Zope Page Templates）, 进行了速度上的优化。</li>
<li>Genshi – Python 模板工具，用以生成 web 感知的结果。</li>
<li>Mako – Python 平台的超高速轻量级模板。</li>
</ul>
<p>Queue</p>
<p>处理事件以及任务队列的库。</p>
<ul>
<li>celery – 一个异步任务队列/作业队列，基于分布式消息传递。</li>
<li>huey – 小型多线程任务队列。</li>
<li>mrq – Mr. Queue -一个 Python 的分布式 worker 任务队列， 使用 Redis 和 gevent。</li>
<li>rq – 简单的 Python 作业队列。</li>
<li>simpleq – 一个简单的，可无限扩张的，基于亚马逊 SQS 的队列。</li>
</ul>
<p>搜索</p>
<p>对数据进行索引和执行搜索查询的库和软件。</p>
<ul>
<li>django-haystack – Django 模块化搜索。</li>
<li>elasticsearch-py – Elasticsearch 的官方底层 Python 客户端。</li>
<li>elasticsearch-dsl-py -Elasticsearch 的官方高级 Python 客户端。</li>
<li>solrpy – solr的 Python 客户端。</li>
<li>Whoosh – 一个快速的纯 Python 搜索引擎库。</li>
</ul>
<p>动态消息</p>
<p>用来创建用户活动的库。</p>
<ul>
<li>django-activity-stream – 从你的站点行为中生成通用活动信息流。</li>
<li>Stream-Framework – 使用 Cassandra 和 Redis 创建动态消息和通知系统。</li>
</ul>
<p>资源管理</p>
<p>管理、压缩、缩小网站资源的工具。</p>
<ul>
<li>django-compressor – 将链接和内联的 JavaScript 或 CSS 压缩到一个单独的缓存文件中。</li>
<li>django-storages – 一个针对 Django 的自定义存储后端的工具集合。</li>
<li>fanstatic – 打包、优化，并且把静态文件依赖作为 Python 的包来提供。</li>
<li>File Conveyor – 一个后台驻留的程序，用来发现和同步文件到 CDNs, S3 和 FTP。</li>
<li>Flask-Assets – 帮你将 web 资源整合到你的 Flask app 中。</li>
<li>jinja-assets-compressor – 一个 Jinja 扩展，用来编译和压缩你的资源。</li>
<li>webassets – 为你的静态资源打包、优化和管理生成独一无二的缓存 URL。</li>
</ul>
<p>电子邮件</p>
<p>用来发送和解析电子邮件的库。</p>
<ul>
<li>django-celery-ses – 带有 AWS SES 和 Celery 的 Django email 后端。</li>
<li>envelopes – 供人类使用的电子邮件库。</li>
<li>flanker – 一个 email 地址和 Mime 解析库。</li>
<li>imbox – Python IMAP 库</li>
<li>inbox.py – Python SMTP 服务器。</li>
<li>inbox – 一个开源电子邮件工具箱。</li>
<li>lamson – Python 风格的 SMTP 应用服务器。</li>
<li>mailjet – Mailjet API 实现，用来提供批量发送邮件，统计等功能。</li>
<li>marrow.mailer – 高性能可扩展邮件分发框架。</li>
<li>modoboa – 一个邮件托管和管理平台，具有现代的、简约的 Web UI。</li>
<li>pyzmail – 创建，发送和解析电子邮件。</li>
<li>Talon – Mailgun 库，用来抽取信息和签名。</li>
</ul>
<p>URL处理</p>
<p>解析URLs的库</p>
<ul>
<li>furl – 一个让处理 URL 更简单小型 Python 库。</li>
<li>purl – 一个简单的，不可变的URL类，具有简洁的 API 来进行询问和处理。</li>
<li>pyshorteners – 一个纯 Python URL 缩短库。</li>
<li>shorturl– 生成短小 URL 和类似 bit.ly 短链的Python 实现。</li>
<li>webargs – 一个解析 HTTP 请求参数的库，内置对流行 web 框架的支持，包括 Flask, Django, Bottle, Tornado和 Pyramid。</li>
</ul>
<p>HTML处理</p>
<p>处理 HTML和XML的库。</p>
<ul>
<li>BeautifulSoup – 以 Python 风格的方式来对 HTML 或 XML 进行迭代，搜索和修改。</li>
<li>bleach – 一个基于白名单的 HTML 清理和文本链接库。</li>
<li>cssutils – 一个 Python 的 CSS 库。</li>
<li>html5lib – 一个兼容标准的 HTML 文档和片段解析及序列化库。</li>
<li>lxml – 一个非常快速，简单易用，功能齐全的库，用来处理 HTML 和 XML。</li>
<li>MarkupSafe – 为Python 实现 XML/HTML/XHTML 标记安全字符串。</li>
<li>pyquery – 一个解析 HTML 的库，类似 jQuery。</li>
<li>untangle – 将XML文档转换为Python对象，使其可以方便的访问。</li>
<li>xhtml2pdf – HTML/CSS 转 PDF 工具。</li>
<li>xmltodict – 像处理 JSON 一样处理 XML。</li>
</ul>
<p>网络站点爬取</p>
<p>爬取网络站点的库</p>
<ul>
<li>Scrapy – 一个快速高级的屏幕爬取及网页采集框架。</li>
<li>cola – 一个分布式爬虫框架。</li>
<li>Demiurge – 基于PyQuery 的爬虫微型框架。</li>
<li>feedparser – 通用 feed 解析器。</li>
<li>Grab – 站点爬取框架。</li>
<li>MechanicalSoup – 用于自动和网络站点交互的 Python 库。</li>
<li>portia – Scrapy 可视化爬取。</li>
<li>pyspider – 一个强大的爬虫系统。</li>
<li>RoboBrowser – 一个简单的，Python 风格的库，用来浏览网站，而不需要一个独立安装的浏览器。</li>
</ul>
<p>网页内容提取</p>
<p>用于进行网页内容提取的库。</p>
<ul>
<li>Haul – 一个可以扩展的图像爬取工具。</li>
<li>html2text – 将 HTML 转换为 Markdown 格式文本</li>
<li>lassie – 人性化的网页内容检索库。</li>
<li>micawber -一个小型网页内容提取库，用来从 URLs 提取富内容。</li>
<li>newspaper – 使用 Python 进行新闻提取，文章提取以及内容策展。</li>
<li>opengraph – 一个用来解析开放内容协议(Open Graph Protocol)的 Python模块。</li>
<li>python-goose – HTML内容/文章提取器。</li>
<li>python-readability– arc90 公司 readability 工具的 Python 高速端口</li>
<li>sanitize – 为杂乱的数据世界带来调理性。</li>
<li>sumy – 一个为文本文件和 HTML 页面进行自动摘要的模块。</li>
<li>textract – 从任何格式的文档中提取文本，Word，PowerPoint，PDFs 等等。</li>
</ul>
<p>表单</p>
<p>进行表单操作的库。</p>
<ul>
<li>Deform – Python HTML 表单生成库，受到了 formish 表单生成库的启发。</li>
<li>django-bootstrap3– 集成了 Bootstrap 3 的 Django。</li>
<li>django-crispy-forms – 一个 Django 应用，他可以让你以一种非常优雅且 DRY（Don’t repeat yourself） 的方式来创建美观的表单。</li>
<li>django-remote-forms– 一个平台独立的 Django 表单序列化工具。</li>
<li>WTForms – 一个灵活的表单验证和呈现库。</li>
<li>WTForms-JSON– 一个 WTForms 扩展，用来处理 JSON 数据。</li>
</ul>
<p>数据验证</p>
<p>数据验证库。多用于表单验证。</p>
<ul>
<li>Cerberus – A mappings-validator with a variety of rules, normalization-features and simple customization that uses a pythonic schema-definition.</li>
<li>colander – 一个用于对从 XML, JSON，HTML 表单获取的数据或其他同样简单的序列化数据进行验证和反序列化的系统。</li>
<li>kmatch – 一种用于匹配/验证/筛选 Python 字典的语言。</li>
<li>schema -一个用于对 Python 数据结构进行验证的库。</li>
<li>Schematics – 数据结构验证。</li>
<li>valideer – 轻量级可扩展的数据验证和适配库。</li>
<li>voluptuous – 一个 Python 数据验证库。主要是为了验证传入 Python的 JSON，YAML 等数据。</li>
</ul>
<p>静态站点生成器</p>
<p>静态站点生成器是一个软件，它把文本和模板作为输入，然后输出HTML文件。</p>
<ul>
<li>Pelican – 使用 Markdown 或 ReST 来处理内容， Jinja 2 来制作主题。支持 DVCS, Disqus.。AGPL 许可。</li>
<li>Cactus – 为设计师设计的静态站点生成器。</li>
<li>Hyde – 基于 Jinja2 的静态站点生成器。</li>
<li>Nikola – 一个静态网站和博客生成器。</li>
<li>Tinkerer – Tinkerer 是一个博客引擎/静态站点生成器，由Sphinx驱动。</li>
<li>Lektor – 一个简单易用的静态 CMS 和博客引擎。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/13/Python-资源-1/" data-id="ciwnb1bfi000k56cywlveesiy" class="article-share-link">Delen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/13/hello-world/" class="article-date">
  <time datetime="2016-12-13T08:57:01.924Z" itemprop="datePublished">2016-12-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/13/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/13/hello-world/" data-id="ciwnb1bft000s56cyipfjs6bm" class="article-share-link">Delen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-程序员的知识管理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/13/程序员的知识管理/" class="article-date">
  <time datetime="2016-12-13T06:04:47.000Z" itemprop="datePublished">2016-12-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/13/程序员的知识管理/">程序员的知识管理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>前言</p>
<p>本文从一个程序员的视角来讨论知识管理，包括以下几个方面：</p>
<p>什么是知识管理<br>为什么要管理知识<br>如何管理知识</p>
<p>什么是知识管理</p>
<p>个人知识管理（Personal Knowledge Management）：一般指个人通过工具建立知识体系并不断完善，进行知识的收集、消化吸收和创新的过程。</p>
<p>知识管理的范围很广，一般的知识管理方法可以参考这篇文章 个人知识管理的方法（<a href="http://www.jianshu.com/p/dbdac17eb9ff）。" target="_blank" rel="external">http://www.jianshu.com/p/dbdac17eb9ff）。</a></p>
<p>为什么要管理知识</p>
<p>计算机行业的一个特点是新技术更新特别快，意味着程序员需要不停地学习，才能跟上行业的发展。所以，知识管理对程序员非常重要。有意识，成体系地管理知识能够：</p>
<p>更有效地学习新的知识。<br>       如果我们已经建立好一个技术知识体系，新的技术也只是在其他技术上建立起来的，有了坚实基础，学习新技术就会更有效。<br>更好地掌握知识。<br>       使用合适的工具，正确的方法，可以更好地掌握知识，让知识凝固在脑海，而不是流走。<br>节约时间成本。<br>       程序员经常遇到同样的问题，例如说部署开发环境的时候，如果有把解决方案记录下来，就能省去重新解决问题的时间。</p>
<p>如何管理知识</p>
<p>程序员的知识获取途径大部分来自于搜索引擎（谷歌可以提高搜索效率）和技术书籍，这与其他行业不同。主要原因是技术知识一个主要来源是互联网，例如说技术博客，技术文档等。因此，程序员的知识管理主要围绕互联网展开（并不意味着书籍就不重要）。</p>
<p>我把程序员的知识管理分为三个过程：</p>
<p>知识积累<br>碎片整理<br>思考加工</p>
<p>知识积累</p>
<p>想想我们习以为常的知识积累方式有哪些？也许记笔记是我们最常用的一种。对于程序员来说，用笔记录笔记并不现实，我刚学 C++ 的时候就是把语法记在笔记上。实际上，这种做法是很低效的。更有效的方法是用笔记软件帮我们记录文章。例如说，印象笔记，有道笔记等。</p>
<p>一开始我看到好的技术文章时，都是加书签存起来。后面发现这样不能离线访问，而且链接可能会失效。后来用上了笔记软件，于是我可以把文章保存到笔记中，随时可以翻出来看。可以说，笔记软件给知识积累带来了极大方便，同时可以分类管理不同的知识。</p>
<p>知识积累难在养成积累的习惯。以前我解决某个问题，谷歌了很久找到一篇文章解决了问题。解决之后并没有记录下来，结果下一次遇到同样问题，我又浪费了很多时间搜索解决方法。重复多次之后，我意识到这是个严重的问题。所以逐渐养成了保存各种文章的习惯。这些网上积累下来的文章，成为了我知识体系的土壤。</p>
<p>现在开始，使用笔记软件分门别类地保存网上看到的文章，这里要着重强调一下分类的重要性，好的分类可以节省你以后重新检索文章的时间，不要把时间浪费在不必要的劳动上。笔记软件一般都会提供浏览器插件，保存起来是很方便的。</p>
<p>碎片整理</p>
<p>我自己经常遇到这样的情况：要用到某个 Linux 命令的时候，经常大费周章地去搜索。有人说直接查 man 手册不是很快吗？确实查 man 手册比查搜索引擎要快，但是有两个问题：一是看了 man 手册的命令语法，我还得试试看；二是如果我不知道命令的名字怎么查 man。所以，最快的方法不是搜索引擎，也不是 man 手册，而是个人 wiki。</p>
<p>与大家平常所知的 wiki 不同，个人 wiki 主要是用来记录知识碎片的，例如说：某个常用命令的语法，特定的软件配置等等。如果还是不理解，可以看看我的个人 Wiki。这些知识碎片是我们初步消化的知识，只不过因为太过碎片，不能够组成完整的知识体系。很多人以为把看到的文章保存到自己的笔记里面，就有一种已经掌握它的错觉，结果保存了成千上百的文章，却一篇都没认真看完。别人的文章是他的知识沉淀，并不是自己的。随时把文章中的精华提取整理到 wiki，才能初步消化知识，为后面的思考加工做准备。</p>
<p>有人会问为什么不用笔记软件记录这些碎片化的知识呢？用 wiki 当然是有理由的：</p>
<p>笔记软件保存的主要是知识原料。我们从网上保存别人的文章到笔记，存下来的知识是别人的，你只是存下来而已，还没经过消化。我们上面把笔记软件定义为知识的仓库，如果把初步消化后的知识也存在那里，会造成一定的混乱。当然你一定要这么做也可以，但我有分层的思维定势，这算是职业病吧。<br>wiki 是随处可访问的。wiki 发布在互联网上，我们可以随时随地访问它。<br>wiki 是分享的。任何人都可以访问你的 wiki，分享自己的知识何乐而不为呢？<br>那么如何制作自己的 wiki 呢？我自己用的是 Simiki，具体用法查看 Simiki-个人Wiki写作。发布到互联网我用的是 Github Page，具体操作自行搜索。</p>
<p>思考加工</p>
<p>写博客是最好的思考加工知识的方法。当年我也是被刘未鹏的 为什么你应该（从现在开始就）写博客 和 书写是为了更好的思考 给带入坑的。写博客的好处我就不提了，看上面两篇文章就够洗脑了。下面我着重谈谈如何写好博客的一点个人经验。</p>
<p>博客少写纯操作指南类的文章。网上大部分博客写的都是纯操作指南类的文章，例如，如何搭建 LAMP 之类，可能作者自己都不清楚为什么要这么做。不是说纯操作指南类的文章不好，相反我觉得这种文章很重要，只是它的位置不对。它应该放在 wiki 中，因为纯操作指南类的文章只是描述步骤，关注点是怎么做，而不是为什么。写博客的关注点应该在为什么，讲清楚为什么要这么做。另外不要钻牛角尖，我说的是纯操作指南，不要以为只要是搭建环境之类的文章都不能写，这里的“纯”代表只给步骤，不提背后的原理。其实写得好的操作指南应该力求让读者知其然，知其所以然。<br>定期写文章。 万事开头难，动笔开始写作很难，一旦开始就停不下来了。养成定期写文章的习惯，至少确保一个月一篇的节奏。<br>自荐文章到各个技术头条。例如说：伯乐头条，开发者头条，极客头条等，有读者才有动力，同时也是保证自己写好文章的监督。<br>写博客的工具。我自己用的是托管在 Github Page 的 Hexo 静态博客。搭建教程见 用hexo搭建github博客（<a href="http://blog.xiaohansong.com/2015/06/17/%E7%94%A8hexo%E6%90%AD%E5%BB%BAgithub%E5%8D%9A%E5%AE%A2/）。如果你有服务器的话，可以试试" target="_blank" rel="external">http://blog.xiaohansong.com/2015/06/17/%E7%94%A8hexo%E6%90%AD%E5%BB%BAgithub%E5%8D%9A%E5%AE%A2/）。如果你有服务器的话，可以试试</a> wordpress，ghost 之类的博客软件。<br>把无法加工的知识写到 Wiki。例如说：git 的一些配置和用法，这些内容在官方文档都能找到，写在博客也只是搬运工，除非你有新的理解。</p>
<p>总结</p>
<p>以上是我摸打滚爬两年多积累的经验之谈，如果你有好的经验欢迎留言交流。一开始我是在 CSDN 写博客，只不过走了不少弯路，后来折腾 个人博客，最后又开了 个人 Wiki。逐渐形成了自己的知识管理方法。最后总结一下：</p>
<p>知识积累：使用笔记软件保存好的文章，积累知识。<br>碎片整理：在个人 wiki 上记录初步消化的知识碎片。<br>思考加工：对存在笔记和 wiki 中知识进行思考加工后写在博客。</p>
<p>以上讲的是如何在互联网中学习积累，但是千万不要忽视了看书这一重要方法，书中的知识是成体系的，知识密度高，网上的文章良莠不齐，不成体系，比较碎片化。合理分配时间看书和上网学习是很重要的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/13/程序员的知识管理/" data-id="ciwnb1bhj002g56cy7hrlwh60" class="article-share-link">Delen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-文件读写" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/13/文件读写/" class="article-date">
  <time datetime="2016-12-13T06:03:54.000Z" itemprop="datePublished">2016-12-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/13/文件读写/">文件读写</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<blockquote>
<blockquote>
<p>f = open(‘test.txt’, ‘r’)<br>f.read()<br>‘Using pandoc\n\nIf no input-file is specified, input is read from stdin. Otherwise, the input-files are concatenated (with a blank line between each) and used as input.<br>f.close()</p>
<p>try:<br>    f = open(‘D:\Markdown\test.txt’, ‘r’)<br>print(f.read())<br>finally:<br>if f:<br>        f.close()</p>
</blockquote>
</blockquote>
</blockquote>
<p>with open(‘D:\Markdown\test.txt’, ‘r’) as f:<br>print(f.read())</p>
<p>f = open(‘D:\Markdown\test.txt’, ‘r’)<br>for line in f.readlines():<br>print(line.strip()) # 把末尾的’\n’删掉<br>Python 2.7.9 (default, Dec 10 2014, 12:24:55) [MSC v.1500 32 bit (Intel)] on win32<br>Type “help”, “copyright”, “credits” or “license” for more information.</p>
<blockquote>
<blockquote>
<blockquote>
<p>f = open(‘D:\Markdown\1.jpg’, ‘rb’)<br>f.read()</p>
</blockquote>
</blockquote>
</blockquote>
<p>Python 3.4.3 (v3.4.3:9b73f1c3e601, Feb 24 2015, 22:44:40) [MSC v.1600 64 bit (AMD64)] on win32<br>Type “help”, “copyright”, “credits” or “license” for more information.</p>
<blockquote>
<blockquote>
<blockquote>
<p>f = open(‘D:\Markdown\test.txt’, ‘r’, encoding=’gb2312’)<br>f.read()<br>f = open(‘D:\Markdown\test.txt’, ‘r’, encoding=’gb2312’, errors=’ignore’)<br>f.read()</p>
<p>f = open(‘D:\Markdown\test.txt’, ‘w’)<br>f.write(‘Hello!’)<br>6<br>f.close()</p>
<p>f = open(‘D:\Markdown\test.txt’, ‘w’, encoding=’gb2312’)<br>f.write(‘Hello World!’)<br>12<br>f.close()</p>
</blockquote>
</blockquote>
</blockquote>
<p>do_rw.py</p>
<p>#!/usr/bin/env python3</p>
<h1 id="coding-utf-8"><a href="#coding-utf-8" class="headerlink" title="-- coding: utf-8 --"></a>-<em>- coding: utf-8 -</em>-</h1><p>from datetime import datetime</p>
<p>with open(‘test.txt’, ‘w’) as f:<br>    f.write(‘今天是 ‘)<br>    f.write(datetime.now().strftime(‘%Y-%m-%d’))</p>
<p>with open(‘test.txt’, ‘r’) as f:<br>    s = f.read()<br>    print(‘open for read…’)<br>    print(s)</p>
<p>with open(‘test.txt’, ‘rb’) as f:<br>    s = f.read()<br>    print(‘open as binary for read…’)<br>print(s)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/13/文件读写/" data-id="ciwnb1bhd002a56cyi671dgol" class="article-share-link">Delen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-操作文件和目录" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/13/操作文件和目录/" class="article-date">
  <time datetime="2016-12-13T06:01:49.000Z" itemprop="datePublished">2016-12-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/13/操作文件和目录/">操作文件和目录</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>D:\Markdown&gt;python<br>Python 2.7.9 (default, Dec 10 2014, 12:24:55) [MSC v.1500 32 bit (Intel)] on win32<br>Type “help”, “copyright”, “credits” or “license” for more information.</p>
<blockquote>
<blockquote>
<blockquote>
<p>import os<br>os.name<br>‘nt’<br>os.uname()<br>posix.uname_result(sysname=’Linux’, nodename=’CentOS7’, release=’3.10.0-327.el7.x86_64’, version=’#1 SMP Thu Nov 19 22:10:57 UTC 2015’, machine=’x86_64’)<br>os.environ<br>os.environ.get(‘PATH’)<br>‘C:\Python27\;C:\Python27\Scripts;C:\Python34\;C:\Python34\Scripts;C:\Windows\system32;C:\Windows;C:\Windows\System32\Wbem;C:\Windows\System32\WindowsPowerShell\v1.0\;C:\Program Files (x86)\Gow\bin;C:\Users\JinYan\AppData\Local\Pandoc\‘<br>os.environ.get(‘x’, ‘default’)<br>‘default’<br>os.path.abspath(‘.’)<br>‘D:\Markdown’<br>os.path.abspath(‘..’)<br>‘D:\‘<br>os.path.join(‘D:\Markdown’, ‘testdir’)<br>‘D:\Markdown\testdir’<br>os.mkdir(‘D:\Markdown\testdir’)<br>os.rmdir(‘D:\Markdown\testdir’)<br>os.mkdir(‘D:\Markdown\testdir’)<br>os.path.split(‘D:\Markdown\testdir\test.txt’)<br>(‘D:\Markdown\testdir’, ‘test.txt’)<br>os.path.splitext(‘D:\Markdown\testdir\test.txt’)<br>(‘D:\Markdown\testdir\test’, ‘.txt’)<br>os.rename(‘test.txt’, ‘test.py’)<br>os.rename(‘test.py’, ‘test.txt’)</p>
<p>import shutil<br>shutil.copy(‘test - 副本.txt’, ‘test.txt’)</p>
<p>import os<br>[x for x in os.listdir(‘.’) if os.path.isdir(x)]<br>[‘testdir’]</p>
<p>[x for x in os.listdir(‘.’) if os.path.isfile(x) and os.path.splitext(x)[1]==’.txt’]<br>[‘test - \xb8\xb1\xb1\xbe.txt’, ‘test.txt’]</p>
</blockquote>
</blockquote>
</blockquote>
<p>do_dir.py</p>
<p>#!/usr/bin/env python3</p>
<h1 id="coding-utf-8"><a href="#coding-utf-8" class="headerlink" title="-- coding: utf-8 --"></a>-<em>- coding: utf-8 -</em>-</h1><p>from datetime import datetime<br>import os</p>
<p>pwd = os.path.abspath(‘.’)</p>
<p>print(‘      Size     Last Modified  Name’)<br>print(‘————————————————————‘)</p>
<p>for f in os.listdir(pwd):<br>    fsize = os.path.getsize(f)<br>    mtime = datetime.fromtimestamp(os.path.getmtime(f)).strftime(‘%Y-%m-%d %H:%M’)<br>    flag = ‘/‘ if os.path.isdir(f) else ‘’<br>print(‘%10d  %s  %s%s’ % (fsize, mtime, f, flag))</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/13/操作文件和目录/" data-id="ciwnb1bha002756cy9jv2xjvw" class="article-share-link">Delen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-单行代码" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/13/单行代码/" class="article-date">
  <time datetime="2016-12-13T06:00:27.000Z" itemprop="datePublished">2016-12-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/13/单行代码/">单行代码</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1、让列表中的每个元素都乘以2</p>
<p>print map(lambda x: x * 2, range(1,11))</p>
<p>2、求列表中的所有元素之和</p>
<p>print sum(range(1,1001))</p>
<p>3、判断一个字符串中是否存在某些词</p>
<p>wordlist = [“scala”, “akka”, “play framework”, “sbt”, “typesafe”]<br>tweet = “This is an example tweet talking about scala and sbt.”</p>
<p>print map(lambda x: x in tweet.split(),wordlist)</p>
<p>4、读取文件</p>
<p>print open(“ten_one_liners.py”).readlines()</p>
<p>5、祝你生日快乐！</p>
<p>print map(lambda x: “Happy Birthday to “ + (“you” if x != 2 else “dear Name”),range(4))</p>
<ol>
<li>过滤列表中的数值</li>
</ol>
<p>print reduce(lambda(a,b),c: (a+[c],b) if c &gt; 60 else (a,b + [c]), [49, 58, 76, 82, 88, 90],([],[]))</p>
<ol>
<li>获取XML web service数据并分析</li>
</ol>
<p>from xml.dom.minidom import parse, parseString<br>import urllib2</p>
<h1 id="注意，我将它转换成XML格式化并打印出来"><a href="#注意，我将它转换成XML格式化并打印出来" class="headerlink" title="注意，我将它转换成XML格式化并打印出来"></a>注意，我将它转换成XML格式化并打印出来</h1><p>print parse(urllib2.urlopen(“<a href="http://search.twitter.com/search.atom?&amp;q=python&quot;)).toprettyxml(encoding=&quot;utf-8" target="_blank" rel="external">http://search.twitter.com/search.atom?&amp;q=python&quot;)).toprettyxml(encoding=&quot;utf-8</a>“)</p>
<ol>
<li>找到列表中最小或最大的一个数字</li>
</ol>
<p>print min([14, 35, -7, 46, 98])<br>print max([14, 35, -7, 46, 98])</p>
<ol>
<li>并行处理</li>
</ol>
<p>import multiprocessing<br>import math</p>
<p>print list(multiprocessing.Pool(processes=4).map(math.exp,range(1,11)))</p>
<ol>
<li>“Sieve of Eratosthenes”算法</li>
</ol>
<p>Python里没有Sieve of Eratosthenes操作符，但这对于Python来说并不是难事。</p>
<p>n = 50 # We want to find prime numbers between 2 and 50</p>
<p>print sorted(set(range(2,n+1)).difference(set((p <em> f) for p in range(2,int(n*</em>0.5) + 2) for f in range(2,(n/p)+1))))</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/13/单行代码/" data-id="ciwnb1bgv001s56cyrk32rey5" class="article-share-link">Delen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-练手的小项目" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/13/练手的小项目/" class="article-date">
  <time datetime="2016-12-13T05:59:19.000Z" itemprop="datePublished">2016-12-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/13/练手的小项目/">练手的小项目</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>文本操作</p>
<p>逆转字符串——输入一个字符串，将其逆转并输出。<br>拉丁猪文字游戏——这是一个英语语言游戏。基本规则是将一个英语单词的第一个辅音音素的字母移动到词尾并且加上后缀-ay（譬如“banana”会变成“anana-bay”）。可以在维基百科上了解更多内容。<br>统计元音字母——输入一个字符串，统计处其中元音字母的数量。更复杂点的话统计出每个元音字母的数量。<br>判断是否为回文——判断用户输入的字符串是否为回文。回文是指正反拼写形式都是一样的词，譬如“racecar”。<br>统计字符串中的单词数目——统计字符串中单词的数目，更复杂的话从一个文本中读出字符串并生成单词数目统计结果。<br>文本编辑器——记事本类型的应用，可以打开、编辑、保存文本文档。可以增加单词高亮和其它的一些特性。<br>RSS源创建器——可以从其它来源读取文本并将其以RSS或者Atom的格式发布出去。<br>实时股价——可以查询股票当前价格。用户可以设定数据刷新频率，程序会用绿色和红色的箭头表示股价走势。<br>访客留言簿/日志——允许人们添加评论或者日记，可以设置开启/关闭评论，并且可以记录下每一条目的时间。也可以做成喊话器。<br>新闻和比分播报器——一个桌面应用，可以从网上收集新闻和比赛分数，将结果在屏幕上滚动播出。<br>占星罗盘——用占星术来预测每天的运程。<br>密码短信——可以将数据加密解密，并能将其发送给朋友。<br>帮你挑礼物——输入一堆你可能会送的礼物，当有人过生日时，该程序会随机选择一样礼物。也可以加上一个额外功能，可以告知哪里可以弄到这个礼物。<br>HTML生成器——将 TEXT 文档转换成HTML文件，对制作网页HTML文档很有用。<br>CD-Key生成器——利用某种算法生成一个唯一的key。软件开发者可以用它来作为软件的激活器。<br>正则表达式查询工具——用户可以输入一段文本，在另外的控件里输入一个正则表达式。运行以后会返回匹配的内容或者正则表达式中的错误。</p>
<p>网络</p>
<p>FTP工具——与远程网络服务器交互文件。<br>原子钟校时——从网上同步原子钟时间。全世界有很多原子钟，可以把它们都列出来。<br>聊天应用（IRC或者MSN风格的）——像IRC那样的聊天室软件或者MSN那样的实时聊天软件。更复杂一点的话，可以为聊天制定一套你自己的传输协议。<br>获取当前天气——获取某个地区当前的天气情况。<br>P2P文件共享应用——像LimeWire、FrostWire、Bearshare或者torrent风格的应用。<br>端口扫描器——输入某个ip地址和端口区间，程序会逐个尝试区间内的端口，如果能成功连接的话就将该端口标记为open。<br>邮件检查工具（POP3/IMAP）——用户输入一些账号信息，包括服务器、ip、协议类型（POP3或者IMAP），应用每隔一段时间就会检查下该账号下的邮箱。<br>数据包嗅探器——侦测电脑上进出的数据包，获取诸如目的地和大小之类的信息。<br>IP注册地查询——输入ip地址，查询该ip是在哪注册的。<br>Whois查询工具——输入一个ip或者主机地址，通过whois查询并将结果返回。<br>邮编查询——输入邮编，返回使用该邮编的地区名称。<br>远程登入——远程登入桌面类型的应用，可以查看和控制远程电脑（假如你已经获得权限）。可能需要你自己的网络和两台电脑来进行测试。<br>网站定时检查器——每隔一段时间或者在预定的时间尝试连接某个网站或者服务器，来检查它是否可以连上，如果连不上了会通过邮件或者桌面通知来告知你。<br>小型网页服务器——简易版的网页服务器，可以存放包含Javascript和其它形式代码的HTML文件。复杂一点的话可以尝试流媒体视频、创建一种服务器端语言或者其它类型的流媒体。<br>网络蜘蛛——一个可以自动执行网页上各种任务的程序，任务包括网站检查、页面抓取、数据摘要以及网络邮务。</p>
<p>类</p>
<p>产品库存管理——创建一个管理产品库存的应用。建立一个产品类，包含价格、id、库存数量。然后建立一个库存类，记录各种产品并能计算库存的总价值。<br>电影商店——管理录像带租借，记录借出时间、到期时间、逾期费用。复杂一点可以生成逾期用户的账号报告。<br>航空/酒店预订系统——创建一套预订航班或酒店的预订系统。不同的航班座位和酒店房间收费不一样。譬如头等舱要比经济舱贵。带阁楼的套间要更贵些。记录下何时有空房可供预订。<br>学生成绩管理器——记录一个班级的学生（创建一个Student类，记录他们的名字、平均分和考试分数）和他们的成绩等级。根据学生的测验和作业的分数计算出平均分和成绩等级。复杂一点可以将数据画在贝尔曲线上。<br>银行账户管家——创建一个名为“Account”的抽象类，有三个为“CheckingAccount”、“SavingsAccount”和“BusinessAccount”的子类。通过类似ATM的程序来管理这些账户的借贷。<br>馆藏目录——创建一个图书类，记录书名、页数、国际标准书号、是否借出。用它来管理各种书籍，允许用户进行借出和归还操作。复杂一点的话，可以生成逾期图书和逾期费用的报告。也可以让用户进行预约操作。</p>
<p>线程处理</p>
<p>下载进度条——创建一个表示下载进度的进度条。进度条由独立的线程操作，通过委托来和主线程进行通讯。<br>下载管理器——允许程序同时下载数个文件，每个都用单独的线程进行背景下载。主线程会关注下载进度并且在下载完成时通知用户。<br>聊天软件（远程聊天）——做一个聊天软件，允许你通过ip直接连接到另一台电脑，也允许你的“服务器”程序处理多个请求连接。<br>批量缩略图生成器——在进行图片转换的处理时会需要很多时间，尤其是图片很大时。做一个图片处理程序，能让你在做其它事的时候在后台线程里将数百张图片转换成某个大小的图片。复杂一点的话可以用一个线程来缩放，用另一个线程来为缩略图重命名。</p>
<p>Web应用</p>
<p>所见即所得编辑器——创建一个在线编辑器，允许用户移动元素、创建表格、书写文本、设置颜色，而用户不必懂HTML。就像Dreamweaver或者FrontPage。如果需要例子的话，可以参看DIC。<br>分页浏览器——创建一个可以分页的小型网页浏览器，可以同时浏览几个网页。简化一点的话不要考虑Javascript或者其它客户端代码。<br>文件下载器——该程序可以从网页上下载各种资源，包括视频和其它文件。用于有很多下载链接的网页。<br>远程登录——创建一个远程登录的应用，可以通过网络登录服务器并能执行一些基本命令。<br>在线白板——做一个在线白板程序，你和朋友们可以一起在白板上进行一些操作，画图、写字等等。<br>带宽监视器——这个小工具可以记录你已经在网上上传和下载多少数据流量了。可以试着做份报告或者图表来展示各时段的使用情况。<br>书签搜集管理器——该程序可以让用户上传书签并将它们排序，去掉重复的，并能生成书签文件以供Firefox/IE/Safari等使用。复杂一点的话可以试着将书签整理进不同的文件夹。<br>密码保险箱——用来记录各种密码，并且将它们加密，这样别人就看不到了。<br>iGoogle媒体播放器小部件——做一个iGoogle小部件，可以用来播放本地音乐列表，也可以每天分享一首歌。也许还可以让别人看到你最近听了些什么歌。<br>基于文本的游戏——做一个像Utopia那样的文本RPG，游戏中，你可以创建一个文明、收集资源、共铸联盟、施放法术、回合制系统。看看是否能够统一王国。<br>定时自动登录——做一个程序可以在预定的时间登录进某个指定的网页并且执行特定的动作，然后在登出。可以用来检查邮箱、发布常规内容、为其它程序获取信息。<br>电子卡片生成器——可以让用户制作自己的电子卡片并发送给其他人。可以使用flash也可以不用。可以使用图片库，也可以加上深刻的格言警句。<br>内容管理系统——像Joomala、Drupal、PHP Nuke这样的内容管理系统。从简单的做起，慢慢增加其它功能。<br>模板制作器——该网站应用允许用户输入各种颜色代码、元素、尺寸，来为PHPBB、Invision Board、MySpace之类的应用创建模板文件。<br>验证码生成器——应该在登录时见过有数字有字母的验证码图片吧？这可以防止自动登录和垃圾广告。试着自己做一个，如果使用PHP的话，看下GD的图片函数。</p>
<p>文件</p>
<p>试卷生成器——该程序可以从文件中随机挑选出不同的题目生成一份试卷。每份试卷可以不一样，通过读取答案来给打分。<br>快速启动——该工具可以添加各个程序的小图标，点击小图标就可以运行程序。和Windows的快速启动类似。<br>文件管理器——做一个文件管理器，要加些新特性，更佳的搜索功能、新图标、新外观。<br>文件记录排序工具——从文件中读取记录，将其排序并写回文件中。允许用户选择排序风格以及排序关键字。<br>生成财务交易文件并且算出平均值——将财务交易读进文件，按照账户分类、算出各项目的总量或平均值、理清各账户的借贷数据。<br>Zip文件生成器——用户输入不同文件夹的文件，也许还包括其他电脑中的文件，然后程序将这些文件打包成zip文件。复杂一点的话，打包时对这些文件进行压缩。<br>PDF生成器——从txt、html或其它文件中读取数据生成PDF文件。可以做成一个网页服务，用户上传文件，返回一个pdf版本。<br>批量文件命名器——程序批量处理一些文件，将根据用户提供的过滤器为它们重命名。譬如用户输入的过滤器为myimage###.jpg，那么会生成至少包含3位数的文件名，譬如myimage001.jpg、myimage145.jpg，甚至是myimage1987.jpg，因为1987也满足了至少包含3位数的条件。<br>MP3标签生成器——修改MP3文件的id3v1标签。还可以试着在MP3文件的头部加入id3v2的标签，譬如album art标签。<br>日志文件生成器——该程序可以记录指定事件的日志。譬如程序做了什么、系统在干什么、文件什么时候被修改了。<br>Excel分页输出器——做一个在线程序，可以读取文件内容生成一个excel分页。可以通过CVS或者其它文件格式来做。复杂一点的话看看是否能创建公式字段。<br>RPG角色属性生成器——做一个程序来给RPG角色随机分配属性点数，可以由用户制定一些分配规则。可以生成职业、性别、力量/魔法/敏捷点数、额外能力或者贸易技能。把结果保存成文件，这样跑团的时候地下城主可以把它打印出来。<br>文件复制工具——该工具可以批量处理文件复制和备份操作。</p>
<p>数据库</p>
<p>SQL查询分析器——该工具可以让用户输入一条查询命令，让其运行于本地数据库中。尽量让它运行得更高效。<br>远程SQL工具——该工具能让你通过网络在远程服务器上执行查询操作。它能接收远程主机地址、验证用户名和密码、执行查询并返回结果。<br>卡片整理器——创建一个在线应用，用来记录搜集到的卡片。可以让用户输入整套卡片，查看哪些已经有了，哪些还需要搜集。要增加复杂度的话，还可以让用户知道还差多少可以完成，或者已经收集卡片的价值。<br>报告生成器——该工具可以根据数据库中的表格生成一份报告。譬如根据订单表格生成销售报告。<br>数据库备份脚本制作器——该程序可以读取数据库的对象、关系、记录和步骤，生成一个sql文件，该文件可以导入另一个数据库或者作为备份文件。<br>备忘录——该程序可以让用户设置一个日期和某个事件的时间、事件备注并将它们放到日历上。用户可以查看日历、搜索特定的事件。复杂一点的话，可以让用户设置重复发生的事件，譬如每天、每周、每月、每年等等。<br>预算记录器——该程序可以记录家庭预算。用户可以添加支出、收入，计算一段时间内的收入和支出。复杂一点的话，让用户指定一个时间段，显示该时间段内的家庭收支情况。<br>电话簿——记录各种联系人和他们的号码、邮箱、备注。复杂一点的话可以让用户连上网将电话簿发布到设置好的网站上。<br>电视节目记录器——你是否有不想错过的电视节目？但没有录像机或者想之后能找到该电视节目然后录下来，那么可以做个程序寻找各种在线电视导航网站，记录下电视节目名称、播放时间、播放频道，存在数据库中。数据库或者网站到时就会发邮件提醒你，节目就快在某个频道开始了。<br>旅行计划系统——该系统可以让用户管理旅行路线，记录下航班和酒店安排、感兴趣的地方、预算和时间表。<br>实体关系图生成器——该程序可以让用户整合实体关系图，并将其保存起来，也可以用它来生成一些基础SQL语句。<br>数据库翻译器（MySQL&lt;-&gt;SQL Server）——该工具可以从数据库A读取数据，生成数据库B使用的SQL语句，将数据存入数据库B。比较常用的是SQL Server和Oracle使用的MySQL服务器。<br>BBS论坛——为你和小伙伴们做一个论坛，可以发帖、管理、分享想法和构思。</p>
<p>图像和多媒体</p>
<p>幻灯片——做一个以幻灯片形式显示各种图片的程序。为了增加难度可以做些额外的效果，譬如渐进检出、星型擦除、窗口渐隐。<br>思维导图——允许用户记录下各种构思并且快速地进行头脑风暴将这些构思整合到一张思维导图中。越快越好，因此要让用户能迅速地写下构思，然后将其拖到可视的导图中去，将构思之间的关系展现出来。<br>导入图片并存成灰度图——该工具将图片上的彩色除尽并保存。可以增加对比度调整、色化等额外功能以增加复杂度。<br>在线流媒体视频——试着自己做一个在线流媒体视频播放器。<br>MP3播放器（以及其他格式的音乐播放器）——该小程序用来播放你最爱的音乐文件。复杂一点的话看看能否加个播放列表功能和均衡器。<br>批量图片处理——该程序可以将一个文件夹内的图片进行统一的处理，譬如降低图片色调、转换格式或者修改文件属性。还可以尝试给图片增加标签。<br>CD烧录器——可以轻松烧录CD的工具。<br>YouTube下载器——可以从Youtube.com上下载视频到硬盘中，要支持包括FLV和AVI在内的文件格式。<br>墙纸管理工具——做一个管理墙纸的程序，可以定时更换刷新墙纸，也可以针对分辨率进行缩放。<br>截屏程序——做一个可以截屏的工具，复杂一点可以增加一个转发邮件的功能。<br>图片浏览器——该程序可以查看电脑上各种格式的图片，譬如PNG、GIF、JPG、BMP、TIFF等等。<br>交通信号灯——试着做一个交通信号灯并且把它放到可以互动的场景中。不要让汽车闯红灯或者撞到其它车。<br>MP3-WAV转换器——MP3格式本质上就是压缩版的WAV。试着将MP3转换成WAV格式以供可以处理WAV格式的程序使用。请记住1MB的MP3大约等于10MB的WAV。<br>签名生成器——是否在网上见过有人的留言后面有条生成的签名？试着做个程序让用户可以指定背景、文字、颜色和对齐方式来定制一个签名档。<br>屏保——电脑空闲时会运行的屏保程序。简单版的可以使用一些标准图片，复杂版的可以做出能在屏幕上转来转去的3D物体。<br>水印——你是否想保护你图片的版权？在图片上加上标志或者文字，这样别人就不能轻易地从你网站上盗图了。做一个程序来给你的图片加上水印吧。<br>海龟图——创建一个20*20的格子，用命令让一只海龟在格子上画线。可以前进、左转、右转，拿起或放下笔等等。复杂一点的话，允许程序从文件中读取命令列表。可以在网上了解到更多关于“海龟图”的信息。</p>
<p>游戏</p>
<p>战船——创建两块游戏面板，玩家各占一边，在上面放置一些战船，玩家看不到对方的面板。每艘船都占几个格子，玩家轮流攻击某个格子，如果格子上有船，那就命中目标，否则就是未命中。当一艘船所占的所有格子都被攻击命中了，那么船就被击沉。谁先将对方战船全部击沉就获胜。<br>象棋跳棋——象棋或者跳棋游戏。可以试着做成可以联网玩，用图形用户界面来实现悔棋、保存走棋过程并且可以回放。<br>刽子手——从文件中随机选择一个单词，让玩家猜单词中的字母。旁边是一幅隐藏的行绞刑的画，猜错一个单词，画就显示出一部分。画全部显示出来时还没能猜全的话玩家就输了。<br>填字游戏——创建一个填字游戏，并为每个词提供一个提示信息，让玩家填上所有正确的单词。<br>青蛙跳——让青蛙跳过河或者马路，过河的话要跳在顺流而下速度各异的木头或者睡莲叶子上，过马路的话要避开速度各异的车子。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/13/练手的小项目/" data-id="ciwnb1bhk002h56cyqqa37kr9" class="article-share-link">Delen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-mail" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/13/mail/" class="article-date">
  <time datetime="2016-12-13T05:58:08.000Z" itemprop="datePublished">2016-12-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/13/mail/">mail</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>���ı�</p>
<p>#encoding:utf-8<br>import smtplib<br>import os<br>from email.mime.text import MIMEText<br>from email.mime.multipart import MIMEMultipart<br>from email import encoders<br>user = ‘yanjin198620@126.com’<br>pwd = ‘<em>*</em>‘<br>to = [‘455177385@qq.com’, ‘sanyuanyanjin@163.com’]<br>msg = MIMEMultipart()<br>msg[‘Subject’] = ‘����…’<br>content1 = MIMEText(‘���ģ�’, ‘plain’, ‘utf-8’)<br>msg.attach(content1)</p>
<p>#———————————————————–<br>s = smtplib.SMTP(‘smtp.126.com’)<br>s.login(user, pwd)<br>s.sendmail(user, to, msg.as_string())<br>print(‘���ͳɹ�’)<br>s.close()</p>
<p>������</p>
<p>#encoding:utf-8<br>import smtplib<br>import os<br>from email.mime.text import MIMEText<br>from email.mime.multipart import MIMEMultipart<br>from email import encoders<br>user = ‘yanjin198620@126.com’<br>pwd = ‘<em>*</em>‘<br>to = [‘455177385@qq.com’, ‘sanyuanyanjin@163.com’]<br>msg = MIMEMultipart()<br>msg[‘Subject’] = ‘����’<br>content1 = MIMEText(‘���Ĳ��֣�’, ‘plain’, ‘utf-8’)<br>msg.attach(content1)<br>attfile = ‘C:\Users\JinYan\Documents\SyncSettings 2016-06-16 152928.log’<br>basename = os.path.basename(attfile)<br>fp = open(attfile, ‘rb’)<br>att = MIMEText(fp.read(), ‘base64’, ‘utf-8’)<br>att[“Content-Type”] = ‘application/octet-stream’<br>att.add_header(‘Content-Disposition’, ‘attachment’,filename=(‘gbk’, ‘’, basename))<br>encoders.encode_base64(att)<br>msg.attach(att)</p>
<p>#———————————————————–<br>s = smtplib.SMTP(‘smtp.126.com’)<br>s.login(user, pwd)<br>s.sendmail(user, to, msg.as_string())<br>print(‘���ͳɹ�’)<br>s.close()</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/13/mail/" data-id="ciwnb1bfv000u56cy9ur0frnk" class="article-share-link">Delen</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/2/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archieven</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recente berichten</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/12/13/Python-自定义函数的特殊属性/">Python 自定义函数的特殊属性</a>
          </li>
        
          <li>
            <a href="/2016/12/13/python实现自动备份文件夹功能/">python实现自动备份文件夹功能</a>
          </li>
        
          <li>
            <a href="/2016/12/13/Python-资源-1/">Python 资源</a>
          </li>
        
          <li>
            <a href="/2016/12/13/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2016/12/13/程序员的知识管理/">程序员的知识管理</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 JinYan<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>