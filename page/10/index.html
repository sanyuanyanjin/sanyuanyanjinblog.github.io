<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>SanYuan</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="SanYuan">
<meta property="og:url" content="http://yoursite.com/page/10/index.html">
<meta property="og:site_name" content="SanYuan">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="SanYuan">
  
    <link rel="alternate" href="/atom.xml" title="SanYuan" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">SanYuan</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Linux-系统恢复" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/13/Linux-系统恢复/" class="article-date">
  <time datetime="2016-12-13T02:02:54.000Z" itemprop="datePublished">2016-12-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/13/Linux-系统恢复/">Linux 系统恢复</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>系统快照可能会碰到的问题是它们对于硬盘故障非常的脆弱。如果你的硬盘受到了严重的物理损伤，那么很可能你的系统快照就无法帮助你恢复系统了。为了防止这一点，我们建议在安装与设置好你的Linux系统之后立即做一份系统快照，然后把它单独复制到另外的存储设备中。<br>在Linux中有一些应用程序可以帮助你保存系统快照。大多数应用程序都是针对于新手的，并不需要高级的Linux操作技巧。我们在这里挑选了一些，你可以从中选择适合自己的应用。<br>TimeShift<br>TimeShift提供了一个非常简洁的图形用户界面，你也可以直接在终端输入命令使用它。默认情况下。TimeShift并不会包含用户的个人文件，但你可以通过自定义将特殊的目录添加到快照中去。Ubuntu及其分支的用户可以从开发者的PPA获取TimeShift：<br>sudo apt-add-repository ppa:teejee2008/ppa sudo apt-get update<br>sudo apt-get install timeshift<br>其他版本的用户可以下载安装文件并在命令行终端运行：<br>./timeshift-latest-amd.64.run<br>TimeShift还提供了专门针对BTRFS文件系统的版本，可以支持原生的BTRFS系统快照功能。<br>工作方式<br>TimeShift能够帮助你随时完成快照工作，或者你也可以设置让TimeShift自动创建快照。你可以安排任务计划，每小时、每天、每周或者每个月进行快照，也可以设置清除这些快照的时间。TimeShift有一个特殊的选项叫做重启快照，用来在每次系统重启之后创建一个新的快照文件。<br>TimeShift从快照中进行系统恢复是一项非常简单直接的工作，只要选择快照文件并且告诉它应该存储的位置就可以了。TimeShift提供了将快照恢复到外设的选项，克隆功能能够直接将现有系统状态复制到另一个设备中，这在将你的操作系统迁移到另一台新电脑时非常方便，因为你不再需要从头开始安装各种功能和应用。<br>在恢复快照之前，TimeShift会询问你是不是需要保存现有的应用设置，并且让你选择保存哪一个。请记住TimeShift需要GRUB 2启动进入快照恢复。<br>Cronopete<br>如果你认为TimeShift的操作已经足够简单的话，那么Cronopete甚至更加简单，至少从外观上看来是这样的。Cronopete自称为OS X的时间机器，与TimeShift工作起来稍有不同。Cronopete为Ubuntu，Debian和Fedora提供了包文件，Arch Linux使用者可以在AUR中找到它。<br>工作方式<br>与本文中介绍的其他应用程序不同，Cronopete将备份与快照功能捆绑在一起，并且要求你将快照保存在外部设备上。默认情况下，它会每个小时都检查一遍你的文件变化，但是当然可以在设置中改变这个时间间隔。如果某个文件并没有发生变化，那么Cronopete将对这个文件只进行一个硬链接而并不复制这份文件，这会帮助节省磁盘空间。<br>Cronopete的文件恢复可能是它最酷的功能，好像真的能帮助你“穿越时间”，也就是说，可视化的浏览所有储存版本的文件与文件夹。想要恢复哪一个文件，只需要选上它，然后点击恢复就可以了，这个文件就会从外部的存储设备中复制到你现有的系统中来。当然这里你可能也猜测到了，Cronopete对于全系统恢复并不十分具有意义，但是如果你想要保存单独文件的多个版本，那么它是一个很好的选择。<br>Back In Time<br>Back In Time的用户界面看起来非常友好，能够吸引住Linux新手。它的设置对话框中提供了非常精细的操作控件，用户界面看上去就像是一个文件管理器一样，在这里你可以阅览所有的快照，浏览快照中的文件，以及恢复选定的文件与文件夹。<br>Ubuntu用户可以从PPA中安装Back In Time：<br>sudo add-apt-repository ppa:bit-team/stable<br>sudo apt-get update<br>sudo apt-get install backintime-qt4<br>有些发行版会在自己的资源库中提供Back In Time，如果你的发行版没有的话，也总可以在网上找到源代码并且下载安装。<br>工作方式<br>Back In Time会对那些你选择的目录创建快照，但是只会恢复那些拥有写权限的目录。你可以对快照进行加密并且存储在网络设备、外部硬盘或者是本地的文件系统中。Back In Time只会对那些改变过的文件进行更新。在设置&gt;选项标签中，你可以选择在没有变化发生的时候禁用快照。<br>Back In Time的快照时间根据计划设定，每天、每周、每个月或者是每天的某个或某几个时间段，或者是每次重启之后。你可以在主工具栏的菜单中自己更改计划时间。<br>与Cronopete相似，Back In Time更加适合于基于文件夹或者是基于文件的回滚操作，但是如果你想对整个文件系统进行回滚也是同样可行的。恢复一个快照相当简单，只要选择它，并且选择在哪里进行恢复就可以了，取决于你是只想恢复几个文件夹还是对整个系统进行恢复。<br>Systemback<br>Systemback的界面很小巧，但是功能却非常强大。但不幸的是只有Debian和Ubuntu及其分支的用户可以使用，而没有提供其他Linux发行版的安装文件。Systemback可以通过开发者PPA安装：<br>sudo add-apt-repository ppa:nemh/systemback<br>sudo apt-get update<br>sudo apt-get install systemback<br>工作方式<br>Systemback并不仅仅是另一个快照工具。它可以把你现在的系统转变为一张live CD或DVD，这样就可以直接在另一台电脑上启动了。它可以修复或重装GRUB 2启动器以及修复fstab文件，当然，Systemback的主要用途还是用于系统快照。<br>Systemback将快照的总数量限制在10个以内。用户拥有删除快照的权限。快照的功能可以选择为递增，也就是只复制被改变过的文件，而将其他的文件以硬链接的形式保存。但是在设置对话框中，你可以禁用这个功能。在恢复文件的时候，你可以选择执行全系统恢复，或者只是复制关键的系统文件。个人数据比如照片与文档并不会被包含在快照中，但是你可以在创建&gt;包含用户数据的选项中通过自定义操作将它们转移到live CD中。<br>Systemback允许用户自定义自动快照的计划，但你也将这个选项关闭来手动设置恢复点。需要注意的是Systemback并不支持NTFS文件系统，因此不能对NTFS系统分区进行快照或者是恢复操作。<br>Snapper<br>Snapper和openSUSE的关系非常密切。在其他Linux版本上也许能够安装Snapper，但是并不一定能正常工作了。在openSUSE中安装Snapper的最简单方法是将它安装在BTRFS分区上，这样做Snapper就能够自动安装与配置。你可以使用命令行工具来操作Snapper，或者通过YaST工具，此外还有另一种替代方案snapper-GUI。<br>工作方式<br>Snapper能够创建几种不同类型的快照，比如在安装新的应用程序之前与之后创建快照。通过这种方式你可以将快照进行对比，并且更有效的进行系统恢复。Snapper会为快照自动建立时间计划，你当然也可以把这个功能禁用掉。在Snapper中，快照是存放在与系统相同的分区中，因此它们会不断长大，要记得随时检查自己的硬盘容量。<br>默认情况下，Snapper只对根分区创建快照。如果想要包含其他分区和BTRFS副磁盘卷，你就需要为每一个项目创建一个配置，这必须在命令行终端中完成，你需要以root权限运行下面的命令：<br>snapper -c CONFIGNAME create-config /PATH<br>在这里-c代表着配置“configure”，CONFIGNAME是你为这个配置所取的名称，/PATH则是分区或是副磁盘卷的位置，例如：<br>snapper -c home create-config /home<br>你可以用下面的命令查看当前的配置：<br>snapper list-configs<br>所有的配置文件都保存在/etc/snapper/configs目录。在这里，你可以用一个常用的文本编辑器来修改它们，例如你可以禁用每小时创建快照的功能，启用自动删除快照的功能，手动设置可保存旧快照的数量。<br>在YaST Snapper模式中，你可以创建并对比快照进行系统回滚操作，或者将一个文件或者其他一些被选择的文件恢复到以前的版本。<br>怎样备份与恢复已安装的应用程序<br>了解了怎样对整个操作系统进行恢复之后，你可能想知道怎样恢复那些已经安装的应用软件。这在系统新版升级或重装系统的情况下很常见。幸运的是已经有一些工具提供了应用程序迁移的功能，而且使用起来非常方便。<br>首先我要提到的是Aptik，它是由TimeShift的开发者创建的应用程序备份工具。<br>Aptik只能用于基于Ubuntu的发行版，你可以直接从开发者PPA安装：<br>sudo apt-add-repository ppa:teejee2008/ppa<br>sudo apt-get update<br>sudo apt-get install aptik<br>Aptik能够以列表的形式输出系统现有的已安装的包以及所使用的库以及下载的包文件。此外还有用于导出应用程序设置、桌面主题和图标集的选项。Aptik会根据安装类型对这些包进行分类，例如分为操作系统预装、用户自主安装、自动安装的依赖与从.deb文件安装等等。对于.deb文件你可以将它们拖拽到列表中并且包含在备份文件里。备份可以保存在任何位置，如果想把它们提取到一个新安装的发行版中，只需要先安装Aptik，然后在主窗口中选择备份并进行恢复即可。<br>Linux Mint的用户可以选择Mint备份工具，功能几乎与Aptik一模一样。除了恢复已安装的应用程序之外，这个工具还可以对所选定的文件夹及其权限执行快速备份。<br>Arch Linux的用户可以使用Backpac来备份与恢复应用程序。Backpac可以建立手动安装包的列表文件，也可以按照你的选择单独备份文件。使用Backpac恢复系统状态会重新安装所输出的包，删除掉快照中并不包含的文件，并且会用之前输出的版本覆盖系统文件。<br>当然，你可以不使用任何一个第三方工具来完成这样的操作。在包管理系统中提供了这样的工具。在基于dpkg的系统中，你可以使用下面的操作来输出一个已安装应用的列表文件：<br>dpkg –get-selections &gt; /home/yourusername/apps.txt<br>然后，将这个txt文件与库信息从/etc/apt/sources.d/目录与/etc/apt/sources.list文件复制到新的系统中。使用如下命令行并提供正确的文件路径就可以将备份的应用迁移到新的系统中：<br>dpkg –set-selections &lt; /path/to/apps.txt<br>sudo apt-get update<br>sudo apt-get dselect-upgrade<br>有些图形化的包管理工具例如Synaptic能够提供图形化的用户界面，用来输出与导入已经安装的应用程序的列表，不需要使用终端命令行的形式来操作。<br>高级系统回滚解决方案<br>如果上面建议的这些应用你并不认为合适，那么我们还有其他的解决方案。我在这里将它们称为“高级”并不意味着这些方案非常复杂，而是说它们可能并不是新手用户的第一选择。<br>如果你想在命令行终端使用一种极简而快速的方法进行快照操作，那么可以试一下Rsnapshot。你可以在绝大多数Linux发行版的资源库中找到它。Rsnapshot的所有设置都在/etc/rsnapshot.conf这个文件中。你可以打开这个文件，自定义快照时间表，设置何时删除旧的快照，以及需要包含哪些文件与文件夹。当你设置完毕之后，最好使用下面两个命令来做一下测试：<br>rsnapshot configtest<br>rsnapshot -t hourly<br>这样可以保证你的所有设置都正常启用。请记住修改设置文件时需要在两个功能选项中使用一个tab符进行分割而并不是空格，因此不要用空格键移动这些参数。Rsnapshot没有自动恢复功能，所以你只能从选定的快照中手动复制文件。<br>Obnam<br>Obnam与Rsnapshot非常相似，另外还提供了一些有趣的功能。它可以先创建一个全系统备份，然后逐渐生成包含新的或是改变过的文件的快照。你可以对快照进行加密与自动解密。Obnam在进行系统恢复时的操作也是相似的，提供命令，并且让你选择存储的位置。<br>你可以设置或是修改自定义路径，将快照存放在服务器上或者是其他远程设备上。Obnam提供的官方手册是一项很了不起的工作，清楚的解释了所有的功能操作。<br>LVM Snapshots<br>如果系统中将会存放一些重要的数据，那么一定要事先考虑好备份与恢复的方法。如果你正在安装与设置Linux系统的话，那么值得考虑将LVM(Logical Volume Manager)作为硬盘的管理工具。<br>准确的说，LVM并不算是一个应用程序，它在Linux内核中提供了内置的快照功能，可以将快照安装到任何其他磁盘或分区，合并若干个快照，并还原它们来解决系统问题。或者你可以使用Linux内核模块dattobd支持对运行中的系统进行增量快照，这样无需卸载分区或重新启动计算机。<br>正如你所看到的，有很多种选择可以在Linux中获得系统恢复功能，然而你会发现它们在技术上是非常相似的，那么有没有更好的方法来代替现有的系统恢复功能呢?也许在未来随着这些应用程序的不断发展将会出现更好的方法，或者是对这些现有的工具更有效的进行组合应用，这些都需要使用者们不断进行探索发掘。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/13/Linux-系统恢复/" data-id="ciwpzcd4i001exjcyqz7ciwcn" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Linux服务器遭受攻击后的一般处理过程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/13/Linux服务器遭受攻击后的一般处理过程/" class="article-date">
  <time datetime="2016-12-13T01:59:07.000Z" itemprop="datePublished">2016-12-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/13/Linux服务器遭受攻击后的一般处理过程/">Linux服务器遭受攻击后的一般处理过程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>安全总是相对的，再安全的服务器也有可能遭受到攻击。作为一个安全运维人员，要把握的原则是：尽量做好系统安全防护，修复所有已知的危险行为，同时，在系统遭受攻击后能够迅速有效地处理攻击行为，最大限度地降低攻击对系统产生的影响。<br>一、处理服务器遭受攻击的一般思路<br>系统遭受攻击并不可怕，可怕的是面对攻击束手无策，下面就详细介绍下在服务器遭受攻击后的一般处理思路。<br>1.切断网络<br>所有的攻击都来自于网络，因此，在得知系统正遭受黑客的攻击后，首先要做的就是断开服务器的网络连接，这样除了能切断攻击源之外，也能保护服务器所在网络的其他主机。<br>2.查找攻击源<br>可以通过分析系统日志或登录日志文件，查看可疑信息，同时也要查看系统都打开了哪些端口，运行哪些进程，并通过这些进程分析哪些是可疑的程序。这个过程要根据经验和综合判断能力进行追查和分析。下面的章节会详细介绍这个过程的处理思路。<br>3.分析入侵原因和途径<br>既然系统遭到入侵，那么原因是多方面的，可能是系统漏洞，也可能是程序漏洞，一定要查清楚是哪个原因导致的，并且还要查清楚遭到攻击的途径，找到攻击源，因为只有知道了遭受攻击的原因和途径，才能删除攻击源同时进行漏洞的修复。<br>4.备份用户数据<br>在服务器遭受攻击后，需要立刻备份服务器上的用户数据，同时也要查看这些数据中是否隐藏着攻击源。如果攻击源在用户数据中，一定要彻底删除，然后将用户数据备份到一个安全的地方。<br>5.重新安装系统<br>永远不要认为自己能彻底清除攻击源，因为没有人能比黑客更了解攻击程序，在服务器遭到攻击后，最安全也最简单的方法就是重新安装系统，因为大部分攻击程序都会依附在系统文件或者内核中，所以重新安装系统才能彻底清除攻击源。<br>6.修复程序或系统漏洞<br>在发现系统漏洞或者应用程序漏洞后，首先要做的就是修复系统漏洞或者更改程序bug，因为只有将程序的漏洞修复完毕才能正式在服务器上运行。<br>7.恢复数据和连接网络<br>将备份的数据重新复制到新安装的服务器上，然后开启服务，最后将服务器开启网络连接，对外提供服务。<br>二、检查并锁定可疑用户<br>当发现服务器遭受攻击后，首先要切断网络连接，但是在有些情况下，比如无法马上切断网络连接时，就必须登录系统查看是否有可疑用户，如果有可疑用户登录了系统，那么需要马上将这个用户锁定，然后中断此用户的远程连接。<br>1.登录系统查看可疑用户<br>通过root用户登录，然后执行“w”命令即可列出所有登录过系统的用户。<br>通过这个输出可以检查是否有可疑或者不熟悉的用户登录，同时还可以根据用户名以及用户登录的源地址和它们正在运行的进程来判断他们是否为非法用户。<br>2.锁定可疑用户<br>一旦发现可疑用户，就要马上将其锁定，例如上面执行“w”命令后发现nobody用户应该是个可疑用户（因为nobody默认情况下是没有登录权限的），于是首先锁定此用户，执行如下操作：<br>[root@server ~]# passwd -l nobody<br>锁定之后，有可能此用户还处于登录状态，于是还要将此用户踢下线，根据上面“w”命令的输出，即可获得此用户登录进行的pid值，操作如下：<br>[root@server ~]# ps -ef|grep @pts/3<br>531 6051 6049 0 19:23 ? 00:00:00 sshd: nobody@pts/3<br>[root@server ~]# kill -9 6051<br>这样就将可疑用户nobody从线上踢下去了。如果此用户再次试图登录它已经无法登录了。<br>3.通过last命令查看用户登录事件<br>last命令记录着所有用户登录系统的日志，可以用来查找非授权用户的登录事件，而last命令的输出结果来源于/var/log/wtmp文件，稍有经验的入侵者都会删掉/var/log/wtmp以清除自己行踪，但是还是会露出蛛丝马迹在此文件中的。<br>三、查看系统日志<br>查 看系统日志是查找攻击源最好的方法，可查的系统日志有/var/log/messages、/var/log/secure等，这两个日志文件可以记录软 件的运行状态以及远程用户的登录状态，还可以查看每个用户目录下的.bash_history文件，特别是/root目录下的.bash_history 文件，这个文件中记录着用户执行的所有历史命令。<br>四、检查并关闭系统可疑进程<br>检查可疑进程的命令很多，例如ps、top等，但是有时候只知道进程的名称无法得知路径，此时可以通过如下命令查看：<br>首先通过pidof命令可以查找正在运行的进程PID，例如要查找sshd进程的PID，执行如下命令：<br>1<br>2<br>[root@server ~]# pidof sshd<br>13276 12942 4284<br>然后进入内存目录，查看对应PID目录下exe文件的信息：<br>1<br>2<br>[root@server ~]# ls -al /proc/13276/exe<br>lrwxrwxrwx 1 root root 0 Oct 4 22:09 /proc/13276/exe -&gt; /usr/sbin/sshd<br>这样就找到了进程对应的完整执行路径。如果还有查看文件的句柄，可以查看如下目录：<br>[root@server ~]# ls -al /proc/13276/fd<br>通过这种方式基本可以找到任何进程的完整执行信息，此外还有很多类似的命令可以帮助系统运维人员查找可疑进程。例如，可以通过指定端口或者tcp、udp协议找到进程PID，进而找到相关进程：<br>[root@server ~]# fuser -n tcp 111<br>111/tcp: 1579<br>[root@server ~]# fuser -n tcp 25<br>25/tcp: 2037<br>[root@server ~]# ps -ef|grep 2037<br>root 2037 1 0 Sep23 ? 00:00:05 /usr/libexec/postfix/master<br>postfix 2046 2037 0 Sep23 ? 00:00:01 qmgr -l -t fifo -u<br>postfix 9612 2037 0 20:34 ? 00:00:00 pickup -l -t fifo -u<br>root 14927 12944 0 21:11 pts/1 00:00:00 grep 2037<br>在 有些时候，攻击者的程序隐藏很深，例如rootkits后门程序，在这种情况下ps、top、netstat等命令也可能已经被替换，如果再通过系统自身 的命令去检查可疑进程就变得毫不可信，此时，就需要借助于第三方工具来检查系统可疑程序，例如前面介绍过的chkrootkit、RKHunter等工 具，通过这些工具可以很方便的发现系统被替换或篡改的程序。<br>五、检查文件系统的完好性<br>检查文件属性是否发生变化是验证文件系统完好性最简单、最直接的方法，例如可以检查被入侵服务器上/bin/ls文件的大小是否与正常系统上此文件的大小相同，以验证文件是否被替换，但是这种方法比较低级。此时可以借助于Linux下rpm这个工具来完成验证，操作如下：<br>[root@server ~]# rpm -Va<br>….L… c /etc/pam.d/system-auth<br>S.5….. c /etc/security/limits.conf<br>S.5….T c /etc/sysctl.conf<br>S.5….T /etc/sgml/docbook-simple.cat<br>S.5….T c /etc/login.defs<br>S.5….. c /etc/openldap/ldap.conf<br>S.5….T c /etc/sudoers<br>..5….T c /usr/lib64/security/classpath.security<br>….L… c /etc/pam.d/system-auth<br>S.5….. c /etc/security/limits.conf<br>S.5….. c /etc/ldap.conf<br>S.5….T c /etc/ssh/sshd_config<br>对于输出中每个标记的含义介绍如下：<br>S 表示文件长度发生了变化<br>M 表示文件的访问权限或文件类型发生了变化<br>5 表示MD5校验和发生了变化<br>D 表示设备节点的属性发生了变化<br>L 表示文件的符号链接发生了变化<br>U 表示文件/子目录/设备节点的owner发生了变化<br>G 表示文件/子目录/设备节点的group发生了变化<br>T 表示文件最后一次的修改时间发生了变化<br>如果在输出结果中有“M”标记出现，那么对应的文件可能已经遭到篡改或替换，此时可以通过卸载这个rpm包重新安装来清除受攻击的文件。<br>不过这个命令有个局限性，那就是只能检查通过rpm包方式安装的所有文件，对于通过非rpm包方式安装的文件就无能为力了。同时，如果rpm工具也遭到替换，就不能通过这个方法了，此时可以从正常的系统上复制一个rpm工具进行检测。<br>对文件系统的检查也可以通过chkrootkit、RKHunter这两个工具来完成，关于chkrootkit、RKHunter工具的使用，下次将展开介绍。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/13/Linux服务器遭受攻击后的一般处理过程/" data-id="ciwpzcd4l001hxjcy5wjsnbt0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Linux使用ntfs-3g挂载NTFS" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/13/Linux使用ntfs-3g挂载NTFS/" class="article-date">
  <time datetime="2016-12-13T01:56:13.000Z" itemprop="datePublished">2016-12-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/13/Linux使用ntfs-3g挂载NTFS/">Linux使用ntfs-3g挂载NTFS</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Open Source: NTFS-3G<br>Latest Download - <a href="http://www.tuxera.com/community/open-source-ntfs-3g/" target="_blank" rel="external">http://www.tuxera.com/community/open-source-ntfs-3g/</a><br>NTFS-3G Manual - <a href="http://www.tuxera.com/community/ntfs-3g-manual/" target="_blank" rel="external">http://www.tuxera.com/community/ntfs-3g-manual/</a><br>stable version - <a href="https://tuxera.com/opensource/ntfs-3g_ntfsprogs-2016.2.22.tgz" target="_blank" rel="external">https://tuxera.com/opensource/ntfs-3g_ntfsprogs-2016.2.22.tgz</a></p>
<p>#Installation<br>tar zxvf /tmp/ntfs-3g_ntfsprogs-2016.2.22.tgz<br>cd ntfs*</p>
<p>#yum install gcc<br>./configure<br>make<br>make install # or ‘sudo make install’ if you aren’t root</p>
<p>#Usage<br>fdisk -l<br>mkdir -p /mnt/windows<br>mount -t ntfs-3g /dev/sda1 /mnt/windows</p>
<p>#You can also make NTFS to be mounted during boot by adding the following line to the end of the /etc/fstab file:<br>vi /etc/fstab<br>/dev/sda1 /mnt/windows ntfs-3g defaults 0 0</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/13/Linux使用ntfs-3g挂载NTFS/" data-id="ciwpzcd4k001gxjcy4at90x0l" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Linux-修改本机-etc-hosts-的-hostName-后经常不生效" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/13/Linux-修改本机-etc-hosts-的-hostName-后经常不生效/" class="article-date">
  <time datetime="2016-12-13T01:54:03.000Z" itemprop="datePublished">2016-12-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/13/Linux-修改本机-etc-hosts-的-hostName-后经常不生效/">Linux 修改本机 /etc/hosts 的 hostName 后经常不生效</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1、Linux修改本机别名/etc/hosts的hostName后经常不生效解决</p>
<p>Linux修改本机别名/etc/hosts的hostName后经常不生效， 比如我们/etc/hosts的内容如下：</p>
<p>#192.68.1.10 message.xxx.com<br>192.68.1.11 message.xxx.com</p>
<p>但是ping message.xxx.com还是指向192.68.1.10。</p>
<p>一般2种解决方案：</p>
<p>1). 重启，这是最直接最可靠稳定的一种方法，如果有些时候不方便重启，则可以使用第二种方法。</p>
<p>2). 修改/etc/sysconfig/network文件，将HOSTNAME修改成对应的别名，如下：</p>
<p>NETWORKING=yes<br>HOSTNAME=host1</p>
<p>修改后重启网络服务</p>
<p>service network restart (本质是/etc/init.d/network) 3).</p>
<p>如果重启服务器后，还是不起作用，应该是本机的dns缓存引起的。</p>
<p>查看nscd是否启用： ps -ef|grep nscd</p>
<p>直接关闭Linux nscd 缓存服务： /etc/init.d/nscd stop</p>
<p>2、Linux的DNS</p>
<p>linux本身是没有dns缓存的,想使用dns缓存的话需要自己安装一个服务程序NSCD(name service cache daemon).</p>
<p>nscd缓存三种服务passwd group hosts，所以它会记录三个库，分别对应源/etc/passwd, /etc/hosts 和 /etc/resolv.conf每个库保存两份缓存，一份是找到记录的，一份是没有找到记录的。每一种缓存都保存有生存时间（TTL）.</p>
<p>安装：</p>
<p>yum install nscd</p>
<p>修改配置文件/etc/nscd.conf,开启dns缓存,修改这一行 enable-cache hosts yes。</p>
<p>如果启用了nscd 服务，才有dns 缓存，否则是没有dns缓存的。</p>
<p>开启 、停止、 重启服务 service nscd start | stop | restart</p>
<p>nscd的配置：</p>
<p>通过编辑/etc/nscd.conf文件，在其中增加如下一行可以开启本地DNS cache：<br>enable-cache hosts yes</p>
<p>阿里云主机上的配置如下：</p>
<p>[root@iZ2571ykq ~]# cat /etc/nscd.conf   </p>
<p>#logfile        /var/log/nscd.log<br>threads         6<br>max-threads     128<br>server-user     nscd<br>debug-level     5<br>paranoia        no<br>enable-cache    passwd      no<br>enable-cache    group       no<br>enable-cache    hosts       yes<br>positive-time-to-live   hosts   5<br>negative-time-to-live   hosts       20<br>suggested-size  hosts       211<br>check-files     hosts       yes<br>persistent      hosts       yes<br>shared          hosts       yes<br>max-db-size     hosts       33554432</p>
<p>相关参数的解释如下：</p>
<p>logfile debug-file-name：指定调试信息写入的文件名。</p>
<p>debug-level value：设置希望的调试级别。</p>
<p>threads number：这是启动的等待请求的线程数。最少将创建5个线程。</p>
<p>server-user user：如果设置了该选项，nscd将作为该用户运行，而不是作为root。如果每个用户都使用一个单独的缓存（-S参数），将忽略该选项</p>
<p>enable-cache service <yes|no>：启用或禁用制定的 服务 缓存。</yes|no></p>
<p>positive-time-to-live service value：设置 service 在指定缓存中正的项目（成功的请求）的TTL（存活时间）。 Value 以秒为单位。较大的值将增加缓存命中率从而减低平均响应时间，但是将增加缓存的一致性问题。</p>
<p>negative-time-to-live service value：设置 service 在指定缓存中负的项目（失败的请求）的TTL（存活时间）。 Value 以秒为单位。如果存在由不在系统数据库中的uid（用户ID）（例如在以root身份解包linux 内核源代码时）所拥有的文件将明显改善性能；应该维持较小的值以降低缓存一致性问题。</p>
<p>suggested-size service value：这是内部散列表的大小， value 应该保持一个素数以达到优化效果。</p>
<p>check-files service <yes|no>：启用或禁用检查属于指定 服务 的文件的改变。这些文件是 /etc/passwd， /etc/group， 以及/etc/hosts。</yes|no></p>
<p>nscd 的查看和清除</p>
<p>nscd缓存DB文件在/var/db/nscd下。</p>
<p>nscd -g 查看统计信息</p>
<p>清除 nscd缓存：</p>
<p>nscd -i passwd<br>nscd -i group<br>nscd -i hosts</p>
<p>当然也先删除缓存库或者停掉nscd服务：</p>
<p>rm -f /var/db/nscd/hosts<br>service nscd restart</p>
<p>或者是直接停止nscd 服务</p>
<p>service nscd stop。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/13/Linux-修改本机-etc-hosts-的-hostName-后经常不生效/" data-id="ciwpzcd4e001bxjcy2qfca1qo" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Linux-Command" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/13/Linux-Command/" class="article-date">
  <time datetime="2016-12-13T01:37:50.000Z" itemprop="datePublished">2016-12-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/13/Linux-Command/">Linux Command</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>不一定刻意去看知识，而是以项目为目标来寻求知识支持,方能学的更快。——仁佳<br>鸟哥的Linux私房菜基础学习篇(第三版)<br>notebook:boot: linux nofb apm=off acpi=off pci=noacpi p125<br>command p149<br>date p151<br>cal p151<br>bc p153<br>man p156<br>info p162<br>nano p164<br>sync p167<br>shutdown p167<br>reboot p168<br>halt p168<br>poweroff p168<br>init p169</p>
<p>chgrp p181<br>chown p182<br>chmod p183</p>
<p>cd p202<br>pwd p202<br>mkdir p203<br>rmdir p204<br>$PATH p204<br>ls p207<br>cp p209<br>rm p212<br>mv p213<br>cat p214<br>tac p215<br>nl p215<br>more p216<br>less p217<br>head p218<br>tail p218<br>od p219<br>touch p220<br>umask p223<br>chattr p225<br>lsattr p226<br>SUID p227<br>SGID p228<br>SBIT p228<br>file p230<br>which p230<br>whereis p231<br>locate p232 updatedb<br>find p233</p>
<p>dumpe2fs p249<br>df p256<br>du p258<br>ln p262<br>fdisk p264<br>partprobe p271<br>mkfs p272<br>mke2fs p273<br>fsck p274<br>badblocks p275<br>mount p275<br>umount p279<br>mknod p281<br>e2label p282<br>tune2fs p282<br>hdparm p283<br>parted p295</p>
<p>compress p303<br>gzip p305<br>zcat p305<br>bzip2 p306<br>bzcat p306<br>tar p307<br>dump p313<br>restore p316<br>mkisofs p320<br>cdrecord p322<br>dd p325<br>cpio p327</p>
<p>vim p336<br>Visual Block p343<br>multitask p346<br>~/.vimrc p347<br>~/.viminfo p347<br>dos2unix p349<br>unix2dos p349<br>iconv -o p350<br>iconv -f big5 -t gb2312<br>iconv -f gb2312 -t utf8 logfile.sh -o logfile.sh</p>
<p>type p359<br>echo p362<br>unset p365<br>env p366<br>set p367<br>PS1 p368<br>export p369<br>locale p371<br>read p373<br>declare p373<br>array p374<br>ulimit p375<br>alias p381<br>unalias p382<br>history p382<br>login p385<br>no-login p386<br>stty p390<br>set p391<br>bash p393<br>pipe p400<br>cut p400<br>grep p401<br>sort p402<br>uniq p403<br>wc p404<br>tee p405<br>tr p405<br>col p406<br>join p407<br>paste p408<br>expand p408<br>split p409<br>xargs p410</p>
<ul>
<li>p411</li>
</ul>
<p>grep p419<br>characters p427<br>sed p428<br>printf p434<br>awk p435<br>diff p439<br>cmp p440<br>patch p440<br>pr p441</p>
<p>test p453<br>sh p473</p>
<p>groups p485<br>newgrp p486<br>useradd p487<br>passwd p491<br>chage p494<br>usermod p495<br>userdel p496<br>finger p497<br>chfn p498<br>chsh p499<br>id p499<br>groupadd p500<br>groupmod p500<br>groupdel p501<br>gpasswd p501<br>setfacl p505<br>getfacl p505<br>su p509<br>sudo p510<br>w p524<br>who p524<br>last p524<br>lastlog p524<br>write p524<br>mesg p525<br>wall p525<br>mail p525<br>pwck p527<br>grpck p527<br>pwconv p527<br>pwunconv p528<br>chpasswd p528<br>grpconv p529</p>
<p>quotacheck p542<br>quotaon p543<br>quotaoff p543<br>edquota p544<br>quota p545<br>repquota p546<br>warnquota p548<br>setquota p550<br>mdadm p554<br>pvscan p565<br>pvcreate p565<br>vgcreate p566<br>vgscan p566<br>vgdisplay p566<br>vgextend p567<br>lvcreate p568<br>resize2fs p571<br>lvresize p573<br>pvdisplay p574<br>LVM 相关指令汇总与LVM 的关闭 p580</p>
<p>at p588<br>atq p590<br>atrm p590<br>batch p590<br>crontab p591<br>anacron p597</p>
<p>&amp; p605<br>[crtl]-z<br>jobs p607<br>fg p607<br>bg p608<br>kill p608<br>nobup p609<br>ps p610<br>ps -l p611<br>ps aux p612<br>top p614<br>pstree p616<br>signal<br>killall p618<br>nice p620<br>renice p621<br>free p622<br>uname p622<br>uptime p623<br>netstat p623<br>dmesg p625<br>vmstat p625<br>fuser p629<br>lsof p630<br>pidof p631<br>SELinux p632<br>getenforce p636<br>sestatus p637<br>setenforce p638<br>chcon p640<br>restorecon p641<br>sealert p642<br>auditd p642<br>audit2why p643<br>seinfo p643<br>sesearch p644<br>getsebool p645<br>setsebool p646<br>semanage p646<br>vsftp p648</p>
<p>rsync p662<br>chkconfig p669<br>ntsysv p670</p>
<p>logrotate p689<br>logwatch p695</p>
<p>runlevel p713<br>depmod p714<br>lsmod p715<br>modinfo p715<br>insmod p716<br>rmmod p716<br>modprobe p716<br>mkinitrd p723<br>grub-install p724</p>
<p>setup p739<br>lpadmin p757<br>lpr p759<br>lp p760<br>lprm p760<br>lspci p762<br>lsusb p763<br>iostat p763<br>sensors-detect p766<br>sensors p768</p>
<p>makefile p784<br>Tarball p788<br>ldconfig p796<br>ldd p797<br>md5sum p798</p>
<p>rpm p807<br>rpmbuild p816<br>yum p824</p>
<p>startx p840<br>xinit p841<br>gtf p853</p>
<p>鸟哥的Linux私房菜服务器架设篇(第三版)<br>p116<br>IP Netmask DHCP Gateway</p>
<p>vim /etc/sysconfig/network-scripts/ifcfg-eth0 p119<br>ifconfig(IP/Netmask) route -n (gateway)</p>
<p>主机名  /etc/sysconfig/network p122<br>DNS  /etc/resolv.conf  dig www.google.com p121<br>私有 IP 对应的主机名 /etc/hosts</p>
<p>/etc/init.d/network restart p120</p>
<p>route p74<br>arp p76<br>dhcp p124<br>adsl p125<br>lsusb p134<br>iwconfig p135<br>/etc/hosts p140</p>
<p>ifconfig p146<br>ifup p149<br>ifdown p149<br>route p149<br>ip p152<br>dhclient p159<br>ping p159<br>traceroute(ms:tracert) p162<br>netstat p164<br>host p167<br>nslookup p168<br>telnet p169<br>ftp p171<br>lftp p172<br>pidgin p174<br>links p178<br>wget p181<br>tcpdump p182<br>wireshark p186<br>nc p190<br>netcat p190</p>
<p>yum p221<br>chcon p250</p>
<p>LAMP 所需软件与其结构 p770<br>yum install httpd mysql mysql-server php php-mysql</p>
<p>Apache 的基本设定 p773<br>vim /etc/httpd/conf/httpd.conf</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/13/Linux-Command/" data-id="ciwpzcd4b0018xjcy60rz39gp" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-linux监控命令" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/13/linux监控命令/" class="article-date">
  <time datetime="2016-12-13T01:36:44.000Z" itemprop="datePublished">2016-12-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/13/linux监控命令/">linux监控命令</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="http://www.multicians.org/" target="_blank" rel="external">http://www.multicians.org/</a></p>
<p>/etc/init.d/network restart<br>vim /etc/sysconfig/network-scripts/ifcfg-eth0</p>
<p>[root@localhost ~]# dmidecode | grep “Product Name”<br>        Product Name: VirtualBox<br>        Product Name: VirtualBox</p>
<p>[root@localhost ~]# dmidecode | grep -i ‘serial number’ | grep CN</p>
<p>[root@localhost ~]# grep name /proc/cpuinfo<br>model name      : Intel(R) Pentium(R) CPU G630 @ 2.70GHz<br>model name      : Intel(R) Pentium(R) CPU G630 @ 2.70GHz</p>
<p>[root@localhost ~]# grep “physical id” /proc/cpuinfo<br>physical id     : 0<br>physical id     : 0</p>
<p>[root@localhost ~]# grep MemTotal /proc/meminfo<br>MemTotal:         244212 kB</p>
<p>[root@localhost ~]# cat /etc/redhat-release<br>CentOS release 6.4 (Final)<br>[root@localhost ~]# uname -r<br>2.6.32-358.el6.x86_64<br>[root@localhost ~]# uname -m<br>x86_64<br>[root@localhost ~]# uname -a<br>Linux localhost.localdomain 2.6.32-358.el6.x86_64 #1 SMP Fri Feb 22 00:31:26 UTC 2013 x86_64 x86_64 x86_64 GNU/Linux</p>
<p>[root@localhost ~]# lsb_release -a<br>-bash: lsb_release: command not found</p>
<p>解决方法：yum install redhat-lsb -y</p>
<p>[root@localhost ~]# lsb_release -a<br>LSB Version:    :base-4.0-amd64:base-4.0-noarch:core-4.0-amd64:core-4.0-noarch:graphics-4.0-amd64:graphics-4.0-noarch:printing-4.0-amd64:printing-4.0-noarch<br>Distributor ID: CentOS<br>Description:    CentOS release 6.4 (Final)<br>Release:        6.4<br>Codename:       Final</p>
<p>[root@localhost ~]# vim /etc/sysconfig/i18n</p>
<p>LANG=”en_US.UTF-8”<br>SYSFONT=”latarcyrheb-sun16”</p>
<p>LANG=en_US</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/13/linux监控命令/" data-id="ciwpzcd5f0027xjcyw6xpja6v" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-我使用过的Linux命令之telnet" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/13/我使用过的Linux命令之telnet/" class="article-date">
  <time datetime="2016-12-13T01:35:30.000Z" itemprop="datePublished">2016-12-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/13/我使用过的Linux命令之telnet/">我使用过的Linux命令之telnet</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>我使用过的Linux命令之telnet - 基于TELNET协议的远程登录工具<br>用途说明</p>
<p>　　telnet命令通常用来远程登录。telnet程序是基于TELNET协议的远程登录客户端程序，最新的TELNET协议版本是RFC854。Telnet协议是TCP/IP协议族中的一员，是Internet远程登陆服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的 能力。在终端使用者的电脑上使用telnet程序，用它连接到服务器。终端使用者可以在telnet程序中输入命令，这些命令会在服务器上运行，就像直接 在服务器的控制台上输入一样。可以在本地就能控制服务器。要开始一个 telnet会话，必须输入用户名和密码来登录服务器。Telnet是常用的远程控制Web服务器的方法。<br>　　但是，telnet因为采用明文传送报文，安全性不好，很多Linux服务器都不开放telnet服务，而改用更安全的ssh方式了。但仍然有很多别的系统可能采用了telnet方式来提供远程登录，因此弄清楚telnet客户端的使用方式仍是很有必要的。<br>　　telnet命令还可做别的用途，比如确定远程服务的状态，比如确定远程服务器的某个端口是否能访问。<br>常用参数</p>
<p>格式：telnet hostname<br>远程登录到hostname指定的机器，采用默认端口23。</p>
<p>格式：telnet hostname port<br>远程登录到hostname指定的机器，采用端口port。</p>
<p>在连接成功之后的使用过程中，还可以使用Ctrl+]来进入命令模式。<br>help 帮助<br>q 退出，关闭telnet连接。</p>
<p>使用示例</p>
<p>示例一 远程服务器无法访问的情形</p>
<p>[root@new55 ~]# telnet 192.168.6.6<br>Trying 192.168.6.6…<br>telnet: connect to address 192.168.6.6: No route to host<br>telnet: Unable to connect to remote host: No route to host<br>[root@new55 ~]#<br>怎么处理这种情况：<br>（1）确认ip地址是否正确？<br>（2）确认ip地址对应的主机是否已经开机？<br>（3）如果主机已经启动，确认路由设置是否设置正确？（使用route命令查看）<br>（4）如果主机已经启动，确认主机上是否开启了telnet服务？（使用netstat命令查看，TCP的23端口是否有LISTEN状态的行）<br>（5）如果主机已经启动telnet服务，确认防火墙是否放开了23端口的访问？（使用iptables-save查看）</p>
<p>示例二 域名无法解析的情形</p>
<p>[root@new55 ~]# telnet www.11111.com<br>www.11111.com/telnet: Name or service not known<br>[root@new55 ~]#<br>怎么处理这种情况：<br>（1）确认域名是否正确？<br>（2）确认本机的域名解析有关的设置是否正确？（/etc/resolv.conf中nameserver的设置是否正确，如果没有，可以使用nameserver 8.8.8.8）<br>（3）确认防火墙是否放开了UDP53端口的访问？（DNS使用UDP协议，端口53，使用iptables-save查看）</p>
<p>示例三 目标主机没有开启telnet服务的情形</p>
<p>[root@new55 ~]# telnet www.163.com<br>Trying 58.242.249.26…<br>telnet: connect to address 58.242.249.26: Connection refused<br>telnet: Unable to connect to remote host: Connection refused<br>[root@new55 ~]#<br>怎么处理这种情况：<br>（1）确认ip地址或者主机名是否正确？<br>（2）确认端口是否正确，是否默认的23端口？</p>
<p>示例四 怎样启动telnet服务？（不推荐开放telnet服务，要使用更安全的ssh服务）</p>
<p>启动telnet服务的步骤：<br>（1）到 /etc/xinetd.d 下打开 telnet 文件，将其中的 disable = yes 改成 disable = no，保存。<br>（2）重新启动xinetd服务：service xinetd restart<br>这样就可以允许非root用户从远程访问了。注意：root账号不允许登录。</p>
<p>示例五 正常telnet的情形</p>
<p>一般情况下不允许root从远程登录，可以先用普通账号登录，然后再用su -切到root用户。<br>[root@new55 ~]# telnet 192.168.6.115<br>Trying 192.168.6.115…<br>Connected to 192.168.6.115 (192.168.6.115).<br>Escape character is ‘^]’.<br>Red Hat Linux release 7.3 (Valhalla)<br>Kernel 2.4.18-3 on an i686<br>login: root<br>Password:<br>Login incorrect</p>
<p>login: root<br>Password:<br>Login incorrect</p>
<p>login: web<br>Password:<br>[web@localhost web]$<br>[web@localhost web]$<br>[web@localhost web]$ su -<br>Password:<br>[root@localhost root]#<br>[root@localhost root]#<br>[root@localhost root]#<br>[root@localhost root]# exit<br>logout</p>
<p>[web@localhost web]$ </p>
<p>[web@localhost web]$<br>[web@localhost web]$ exit<br>logout</p>
<p>Connection closed by foreign host.<br>[root@new55 ~]#</p>
<p>示例六 使用telnet来测试web服务器</p>
<p>[root@new55 ~]# telnet www.163.com 80<br>Trying 58.242.249.26…<br>Connected to www.163.com (58.242.249.26).<br>Escape character is ‘^]’.<br>GET / HTTP/1.0 </p>
<p>HTTP/1.0 403 Forbidden<br>Server: Cdn Cache Server V2.0<br>Date: Tue, 07 Dec 2010 04:46:12 GMT<br>Content-Type: text/html<br>Content-Length: 1156<br>Expires: Tue, 07 Dec 2010 04:46:12 GMT<br>X-Via: 1.0 hf44:8104 (Cdn Cache Server V2.0)<br>Connection: close</p>
<p>&lt; !DOCTYPE HTML PUBLIC “-//W3C//DTD HTML 4.01 Transitional//EN” “<a href="http://www.w3.org/TR/html4/loose.dtd&quot;&gt;" target="_blank" rel="external">http://www.w3.org/TR/html4/loose.dtd&quot;&gt;</a><br>&lt; HTML&gt;<head><br>&lt; META HTTP-EQUIV=”Content-Type” CONTENT=”text/html; charset=gb2312”&gt;<br>&lt; TITLE&gt;错误：您所请求的网址（URL）无法获取<br>&lt; STYLE type=”text/css”&gt;<!--BODY{background-color:#ffffff;font-family:verdana,sans-serif}PRE{font-family:sans-serif}--><br>&lt; /HEAD&gt;</head><body><br>&lt; H1&gt;错误<br>&lt; H2&gt;您所请求的网址（URL）无法获取<br>&lt; HR noshade size=”1px”&gt;<br>&lt; P&gt;<br>当尝试读取以下网址（URL）时：</body></p>
<a href="http://58.242.249.44/" target="_blank" rel="external">http://58.242.249.44/</a><br>&lt; P&gt;<br>发生了下列的错误：<br><ul><br>&lt; LI&gt;<br>&lt; STRONG&gt;<br>Access Denied.<br>&lt; BR&gt;拒绝访问<br><br>&lt; P&gt;<br>Access control configuration prevents your request from<br>being allowed at this time.  Please contact your service provider if<br>you feel this is incorrect.<br>&lt; BR&gt;<br>当前的存取控制设定禁止您的请求被接受，<br>如果您觉得这是错误的，请与您网路服务的提供者联系。<br></ul><br>&lt; /P&gt;<br>&lt; P&gt;本缓存服务器管理员：<a href="mailto:cdnsupport@chinanetcenter.com" target="_blank" rel="external">cdnsupport@chinanetcenter.com</a>


<p>&lt; BR clear=”all”&gt;<br>&lt; HR noshade size=”1px”&gt;<br>&lt; ADDRESS&gt;<br>Generated Tue, 07 Dec 2010 04:46:12 GMT by cache.51cdn.com (Cdn Cache Server V2.0)<br>&lt; /ADDRESS&gt;<br>&lt; /BODY&gt;<br>Connection closed by foreign host.<br>[root@new55 ~]# telnet www.163.com 80<br>Trying 58.242.249.26…<br>Connected to www.163.com (58.242.249.26).<br>Escape character is ‘^]’.<br>GET / HTTP/1.0<br>Host: www.163.com</p>
<p>这里会输出响应头和首页html文本，省略。</p>
<p>[root@new55 ~]#</p>
<p>示例七 进入telnet命令模式</p>
<p>[root@new55 ~]# telnet 192.168.6.115<br>Trying 192.168.6.115…<br>Connected to 192.168.6.115 (192.168.6.115).<br>Escape character is ‘^]’.<br>Red Hat Linux release 7.3 (Valhalla)<br>Kernel 2.4.18-3 on an i686<br>login: web<br>Password:<br>Last login: Tue Oct 19 21:53:15 from 192.168.6.55<br>[web@localhost web]$<br>[web@localhost web]$<br>[web@localhost web]$<br>[web@localhost web]$ Ctrl+]<br>telnet&gt; help<br>Commands may be abbreviated.  Commands are:</p>
<p>close           close current connection<br>logout          forcibly logout remote user and close the connection<br>display         display operating parameters<br>mode            try to enter line or character mode (‘mode ?’ for more)<br>open            connect to a site<br>quit            exit telnet<br>send            transmit special characters (‘send ?’ for more)<br>set             set operating parameters (‘set ?’ for more)<br>unset           unset operating parameters (‘unset ?’ for more)<br>status          print status information<br>toggle          toggle operating parameters (‘toggle ?’ for more)<br>slc             change state of special charaters (‘slc ?’ for more)<br>auth            turn on (off) authentication (‘auth ?’ for more)<br>encrypt         turn on (off) encryption (‘encrypt ?’ for more)<br>forward         turn on (off) credential forwarding (‘forward ?’ for more)<br>z               suspend telnet<br>!               invoke a subshell<br>environ         change environment variables (‘environ ?’ for more)<br>?               print help information<br>telnet&gt; display<br>will flush output when sending interrupt characters.<br>won’t send interrupt characters in urgent mode.<br>won’t send login name and/or authentication information.<br>won’t skip reading of ~/.telnetrc file.<br>won’t map carriage return on output.<br>will recognize certain control characters.<br>won’t turn on socket level debugging.<br>won’t print hexadecimal representation of network traffic.<br>won’t print user readable output for “netdata”.<br>won’t show option processing.<br>won’t print hexadecimal representation of terminal traffic.</p>
<p>echo            [^E]<br>escape          [^]]<br>rlogin          [off]<br>tracefile       “(standard output)”<br>flushoutput     [^O]<br>interrupt       [^C]<br>quit            [^]<br>eof             [^D]<br>erase           [^?]<br>kill            [^U]<br>lnext           [^V]<br>susp            [^Z]<br>reprint         [^R]<br>worderase       [^W]<br>start           [^Q]<br>stop            [^S]<br>forw1           [off]<br>forw2           [off]<br>ayt             [^T]<br>     DO   ECHO<br>resp WILL_WONT ECHO: 1<br>want WONT ECHO<br>     DO   SUPPRESS GO AHEAD<br>     DO   STATUS<br>     WILL TERMINAL TYPE<br>     WILL NAWS<br>     WILL TSPEED<br>     WILL LFLOW<br>resp WILL_WONT XDISPLOC: 1<br>want WONT XDISPLOC<br>     WILL NEW-ENVIRON</p>
<p>[web@localhost web]$<br>[web@localhost web]$<br>[web@localhost web]$ Ctrl+]<br>telnet&gt; q<br>Connection closed.<br>[root@new55 ~]#</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/13/我使用过的Linux命令之telnet/" data-id="ciwpzcd6m003txjcyd2qjtax8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-linux定时任务crond那些事" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/13/linux定时任务crond那些事/" class="article-date">
  <time datetime="2016-12-13T01:34:03.000Z" itemprop="datePublished">2016-12-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/13/linux定时任务crond那些事/">linux定时任务crond那些事</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.定时任务crond介绍<br>1.1 crond是什么<br>crond是linux系统中用来定期执行命令或指定程序任务的一种服务或软件。<br>特殊需求：（秒级别）crond服务就无法搞定了，一般工作中写脚本守护进程执行。<br>1.2 为什么要使用crond定时任务<br>linux系统的定时任务crond,相当于我们平时生活中的闹钟的功能。可以满足周期性执行任务的需求。<br>1.3 不同系统的定时任务和种类<br>1.3.1 windows 7 系统的定时任务<br>开始→所有程序→附件→系统工具→选择任务计划程序<br>1.3.2 linux系统的定时任务<br>linux系统中定时任务调度的工作可以分为以下两个情况：<br>① linux系统自身定期执行的任务工作：系统周期性执行的任务工作，如轮询系统日志，备份系统数据，清理系统缓存等。<br>centos5.X例：<br>[root@CentOS5 log]# ll messages<em><br>-rw——- 1 root root 372258 Mar 14 20:48 messages<br>-rw——- 1 root root 349535 Nov 11 18:13 messages.1<br>提示：centos 6.4日志轮询结尾是按时间了。<br>centos6.X例：<br>[root@CentOS6 log]# ll messages</em><br>-rw——- 1 root root  1591 3月  25 21:57 messages<br>-rw——- 1 root root 78304 3月   3 20:40 messages-20140303<br>-rw——- 1 root root 78050 3月   8 19:42 messages-20140311<br>-rw——- 1 root root   745 3月  18 00:46 messages-20140318<br>-rw——- 1 root root 77232 3月  22 21:20 messages-20140325</p>
<p>② 用户执行的任务工作：某个用户或系统管理员定期要做的任务工作，例如每隔5分钟和互联网上时间服务器进行时间同步，每天晚上0点备份站点数据及数据库数据，一般这些工作需要由每个用户自行设置才行。<br>例：<br>[root@CentOS6 log]# crontab -l</p>
<p>#time sync by lee at 2014-1-14<br><em>/5 </em> <em> </em> * /usr/sbin/ntpdate  time.windows.com &gt;/dev/null  2&gt;&amp;1</p>
<p>2.定时任务crond使用说明<br>[root@CentOS6 log]# crontab –help<br>crontab：无效选项 – -<br>crontab: usage error: unrecognized option<br>usage:  crontab [-u user] file<br>        crontab [-u user] [ -e | -l | -r ]<br>                (default operation is replace, per 1003.2)<br> -e      (edit user’s crontab)<br> -l      (list user’s crontab)<br>        -r      (delete user’s crontab)<br>        -i      (prompt before deleting user’s crontab)<br>        -s      (selinux context)</p>
<p>2.1 指令说明<br>通过crontab我们可以在固定的间隔时间执行指定的系统指令或script脚本。时间间隔的单位是分钟，小时，日，月，周及以上的任意组合（注意：日和周不要组合）<br>2.2 使用者权限及定时任务文件<br>文件<br>说明<br>/etc/cron.deny<br>该文件中所列用户不允许使用crontab命令。<br>/etc/cron.allow<br>该文件中所列用户允许使用crontab命令，优先于/etc/cron.deny<br>/var/spool/cron<br>所有用户crontab配置文件默认都存放在此目录，文件名以用户名命名。<br>2.3 指令选项说明表<br>参数<br>含义<br>指定示例<br>-l（字母）<br>查看crontab文件内容<br>crontab -l<br>-e<br>编辑crontab文件内容<br>crontab -e<br>-i<br>删除crontab文件内容，删除前会提示确认<br>crontab -ri<br>-r<br>删除crontab文件内容<br>crontab -r<br>-u user<br>指定使用的用户执行任务<br>crontab -u lee -l<br>提示：crontab{-l |-e}实际上就是在操作/var/spool/cron/当前用户这样的文件。<br>注：<br>crontab -e<br>/var/spool/cron/root<br>前者会检查语法，而后者不会。<br>visudo<br>/etc/sudoers<br>前者会检查语法，而后者不会。</p>
<p>2.4指令的使用格式<br>默认情况下，当用户建立定时任务规则后，该规则记录对应的配置文件会存在于/var/spool/cron中，其crontab配置文件对应的文件名与登录的用户名一致。如：root用户的定时任务配置文件为/var/spool/cron/root。<br>crontab用户的定时任务一般分为6段（空格分隔，系统的定时任务则/etc/crontab分为7段），其中前五段位时间设定段，第六段为所要执行的命令或脚本任务段。<br>2.4.1 crontab基本格式</p>
<ul>
<li><ul>
<li><ul>
<li><ul>
<li><ul>
<li>cmd<br>提示：<br>① cmd为要执行的命令或脚本，例如/bin/sh  /server/scripts/lee.sh.<br>② 每个段之间必须要有空格。<br>2.4.2 crontab语法格式中时间段的含义表<br>段<br>含义<br>取值范围<br>第一段<br>代表分钟<br>00-59<br>第二段<br>代表小时<br>00-23<br>第三段<br>代表日期<br>01-31<br>第四段<br>代表月份<br>01-12<br>第五段<br>代表星期<br>0-7（0和7都代表星期日）<br>2.4.3 crontab语法格式中特殊符号的含义表<br>特殊符号<br>含义<br><em>
</em>号表示任意时间都，就是“每”的意思，举例：如00 01 <em> </em> <em> cmd表示每月每周每日的凌晨1点执行cmd任务。<br>-<br>减号，表示分隔符，表示一个时间范围段，如17-19点，每小时的00分执行任务。00 17-19 </em> <em> </em> cmd。就是17,18,19点整点分别执行的意思。<br>，<br>逗号，表示分隔时间段的意思。30 17,18,19 <em> </em> <em> cmd 表示每天17,18,19点的半点执行cmd。也可以和“-”结合使用，如： 30 3-5,17-19 </em> <em> </em> cmd。<br>/n<br>n代表数字，即”每隔n单位时间”,例如：每10分钟执行一次任务可以写 <em>/10 </em> <em> </em> <em> cmd,其中 </em>/10，*的范围是0-59，也可以写成0-59/10。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>3.书写crond定时任务7个基本要领<br>3.1 为定时任务规则加必要的注释<br>加了注释，就知道定时任务运行的是什么作业，以防以后作业混乱。这是个好习惯和规范。<br>[root@angelT ~]# crontab -l</p>
<p>#time sync by lee at 2014-1-14<br><em>/5 </em> <em> </em> * /usr/sbin/ntpdate  time.windows.com &gt;/dev/null  2&gt;&amp;1</p>
<p>3.2 定时任务命令或程序最好写到脚本里执行<br>[root@angelT ~]# crontab -l</p>
<p>#backup www to /backup<br>00 00 <em> </em> * /bin/sh /server/scripts/www_bak.sh &gt;/dev/null  2&gt;&amp;1</p>
<p>3.3定时任务执行的脚本要规范路径，如：/server/scripts<br>[root@angelT ~]# crontab -l</p>
<p>#backup www to /backup<br>00 00 <em> </em> * /bin/sh /server/scripts/www_bak.sh &gt;/dev/null  2&gt;&amp;1</p>
<p>3.4执行shell脚本任务时前加/bin/sh<br>执行定时任务时，如果是执行脚本，尽量在脚本前面带上/bin/sh命名，否则有可能因为忘了为脚本设定执行权限，从而无法完成任务。<br>[root@angelT ~]# crontab -l</p>
<p>#backup www to /backup<br>00 00 <em> </em> * /bin/sh /server/scripts/www_bak.sh &gt;/dev/null  2&gt;&amp;1</p>
<p>3.5 定时任务结尾加 &gt;/dev/null 2&gt;&amp;1<br>[root@angelT ~]# crontab -l</p>
<p>#backup www to /backup<br>00 00 <em> </em> * /bin/sh /server/scripts/www_bak.sh &gt;/dev/null  2&gt;&amp;1<br>3.5.1 有关/dev/null的说明<br>/dev/null为特殊的字符设备文件，表示黑洞设备或空设备。<br>[root@angelT ~]# ll /dev/null<br>crw-rw-rw- 1 root root 1, 3 3月  26 01:10 /dev/null<br>3.5.2 有关重定向的说明</p>
<blockquote>
<p>或1&gt;   输出重定向：把前面输出的东西输入到后边的文件中，会删除文件原有内容。</p>
<blockquote>
<p>或1&gt;&gt;追加重定向：把前面输出的东西追加到后边的文件中，不会删除文件原有内容。<br>&lt;或<0 2="" 输入重定向：输入重定向用于改变命令的输入，指定输入内容，后跟文件名。="" <<或<<0输入重定向：后跟字符串，用来表示“输入结束”，也可用ctrl+d来结束输入。="">       错误重定向：把错误信息输入到后边的文件中，会删除文件原有内容。<br>2&gt;&gt;     错误追加重定向：把错误信息追加到后边的文件中，不会删除文件原有内容。<br>标准输入（stdin）：代码为0，使用&lt;或&lt;&lt;。<br>标准输出（stdout）:代码为1，使用&gt;或&gt;&gt;。正常的输出。<br>标准错误输出（sederr）：代码为2，使用2&gt;或2&gt;&gt;。<br>特殊：<br>2&gt;&amp;1就是把标准错误重定向到标准输出（&gt;&amp;）。<br>/dev/null 2&gt;&amp;1 等价于 1&gt;/dev/null  2&gt;/dev/null<br>3.5.3 &gt;/dev/null 2&gt;&amp;1的作用<br>如果定时任务规范结尾不加 &gt;/dev/null 2&gt;&amp;1,很容易导致硬盘inode空间被占满，从而系统服务不正常（var/spool/clientmqueue邮件临时队列目录，垃圾文件存放于此，如果是centos 6.4系统，默认不装sendmail服务，所以不会有这个目录。）</0></p>
</blockquote>
</blockquote>
<p>3.6 在指定用户下执行相关定时任务<br>这里要特别注意不同用户的环境变量问题，如果是调用了系统环境变量/etc/profile，最好在程序脚本中将用到的环境变量重新export下。</p>
<p>3.7生产任务程序不要随意打印输出信息<br>在调试好脚本程序后，应尽量把DEBUG及命令输出的内容信息屏蔽掉，如果确实需要输出日志，可定向到日志文件里，避免产生系统垃圾。</p>
<p>配置定时任务规范操作过程<br>①首先要在命令行操作成功，然后复制成功的命令到脚本里，在各个细小环境减少出错的机会。<br>②然后测试小本，测试成功后，复制脚本的规范路径到定时任务配置里，不要手敲。<br>③先在测试环境下测试，然后正式环境规范部署。</p>
<p>4.生产场景如何调试crond定时任务<br>规范的公司开发和运维人员操作流程：个人的开发配置环境–&gt;办公室的测试环境–&gt;idc机房的测试环境–&gt;idc机房的正式环境。<br>4.1 增加执行频率调试任务<br>在调试时，把任务执行频率调快一点，看能不能正常执行，如果正常，那就没问题了，再改成需要的任务的执行时间。<br>注意：有些任务时不允许频繁执行的，例如：定时往数据库里插入数据，这样的任务要在测试机上测试好，然后正式线上出问题的机会就少了。</p>
<p>4.2调整系统时间调试任务<br>用正确的执行任务的时间，设置完成后，可以修改下系统当前时间，改成任务执行时间的前几分钟来测试（或者重启定时任务服务）<br>4.3通过日志输出调试定时任务<br>在脚本中加入日志输出，然后把输出打到指定的日志中，然后观察日志内容的结果，看是否正确执行。<br>4.4注意一些任务命令带来的问题<br>注意： <em> </em> <em> </em> * echo “==”&gt;&gt;/tmp/lee.log &gt;/dev/null 2&gt;&amp;1 这里隐藏的无法正确执行的任务配置，原因是前面多了&gt;&gt;,或者去掉结尾的 &gt;/dev/null 2&gt;&amp;1。<br>4.5 注意环境变量导致的定时任务故障<br>例如：在调试java程序任务的时候，注意环境变量，把环境变量的定义加到脚本里。<br>4.6通过定时任务日志调试定时任务<br>[root@angelT ~]# tail -f /var/log/cron<br>Mar 26 15:55:01 angelT CROND[3415]: (ida) CMD (/usr/sbin/ntpdate time.windows.com &gt;/dev/null 2&gt;&amp;1)<br>Mar 26 15:55:01 angelT CROND[3416]: (root) CMD (/usr/sbin/ntpdate  time.windows.com &gt;/dev/null  2&gt;&amp;1)<br>Mar 26 16:00:01 angelT CROND[3422]: (root) CMD (/usr/sbin/ntpdate  time.windows.com &gt;/dev/null  2&gt;&amp;1)<br>Mar 26 16:00:01 angelT CROND[3423]: (root) CMD (/usr/lib64/sa/sa1 1 1)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/13/linux定时任务crond那些事/" data-id="ciwpzcd5d0024xjcykwvxqmjm" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-cp复制目录时排除一个或者多个目录的方法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/13/cp复制目录时排除一个或者多个目录的方法/" class="article-date">
  <time datetime="2016-12-13T01:30:39.000Z" itemprop="datePublished">2016-12-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/13/cp复制目录时排除一个或者多个目录的方法/">cp复制目录时排除一个或者多个目录的方法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>说明：/home目录里面有data目录，data目录里面有a、b、c、d、e五个目录，现在要把data目录里面除过e目录之外的所有目录拷贝到/bak目录中</p>
<p>方法一：终端命令行下执行以下命令</p>
<p>cp -R ‘find /home/data -type d -path /home/data/e -prune -o -print | sed 1d’ /bak</p>
<p>########################################################<br>脚本实现<br>脚本存放路径/home/piaoyun.sh<br>vi /home/osyunwei.sh #编辑脚本，添加下面的代码</p>
<p>#!/bin/sh<br>cp -R ‘find /home/data -type d -path /home/data/e -prune -o -print | sed 1d’ /bak</p>
<p>chmod +x /home/piaoyun.sh #添加脚本执行权限<br>cd /home #进入脚本存放目录<br>./piaoyun.sh #执行脚本</p>
<p>########################################################</p>
<p>方法二：使用cp命令复制的时候，只能排除一个目录不被复制，如果想排除两个或者多个目录的话，就需要使用rsync命令来实现了，看下面的例子<br>如果要排除/home/data目录下面的a、b、c、三个目录，同时拷贝其它所有目录，执行以下命令</p>
<p>yum install rsync #安装rsync</p>
<p>rsync -av –exclude data/a –exclude data/b –exclude data/c data /bak</p>
<p>注意：–exclude后面的路径不能为绝对路径，必须为相对路径才可以，否则出错。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/13/cp复制目录时排除一个或者多个目录的方法/" data-id="ciwpzcd5b0022xjcyx5nbe8gf" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-用cp命令复制大量文件" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/13/用cp命令复制大量文件/" class="article-date">
  <time datetime="2016-12-13T01:29:04.000Z" itemprop="datePublished">2016-12-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/13/用cp命令复制大量文件/">用cp命令复制大量文件</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近，我有一个复制大量文件的需求，虽然我已经在Unix各种变种上有超过20年的工作经验，但是我仍然被cp指令的行为震撼，我认为这些心得很值得和大家分享下。</p>
<p>首先介绍下机器：一台戴尔服务器（双核，内存最初是2G，后来扩展到10G，运行ubuntu系统），服务器配备的是全新戴尔存储套件<br>MD1200，该套件包括12个4TB硬盘，其中40TB采用RAID6配置，这样整个系统就可以容忍两块硬盘同时down掉。这台服务器主要用作异地备份，唯一的操作是IO写，由于我使用rsnapshot完成这项工作，<br>因此大部分文件有较高的链接计数（30+）。</p>
<p>一天早上，我被告知一个硬盘down掉了。</p>
<p>这不是什么大事，这种事情经常发生。我打电话给戴尔，戴尔第二天就给送来了一块替换盘。但我安装替换盘时发现，替换盘根本不能工作，并且另一块磁盘也down掉了。戴尔技术服务部门富有经验地建议我不要只换down掉的硬盘，因为整个磁盘阵列可能已经损毁了。</p>
<p>就我所知，磁盘只有在有足够多坏块的情况下才会告警，设想这样一个场景：短时间内，一个文件位于三个磁盘上的备份块全部坏掉，那么很不幸，RAID引擎短时间内难以完成检测坏块、重新计算备份数据并存储这样一个流程，这样你就有丢失数据的风险了。因此，如果两个硬盘显式告警，你的数据可能已经丢失了。</p>
<p>现有存储套件容量已经难以达到要求，我们决定扩容，把文件从旧存储套件拷贝到新套件中。正常情况下，我会在块级别拷贝用dd指令或者pvmove指令拷贝数据，但是考虑到坏块，我决定采用文件级别的拷贝，因为这样的话，我就可以知道那些文件包含坏块了。</p>
<p>我上网搜了相关经验，发现cp可以完美地解决这个问题。若想保存硬链接信息，需要记录有哪些文件已经被复制，所以我预订了8G的RAM，并配置了更大的交换区。</p>
<p>当新的存储套件到货，我就着手复制了，起初，根据iotop的测量数据，复制速度接近于300-400MB/s。不一会儿速度便显著下降了，因为大<br>部分时间花在了建立硬链接上，并且要花时间去处理文件系统的一致性问题。</p>
<p>为保持一致性，我们使用了XFS，由于没有关闭写屏障，我们深受性能之苦，但如果RAID控制器配置了带有备份电源的写缓存，一致性问题便可更好地解决。正如所料，cp的内存占用量稳步增加，很快便达到了GB级。</p>
<p>经历了几天的拷贝，问题来了：我发现系统已经停止拷贝，根据strace的显示，cp指令没有调用任何的系统调用函数。阅读相关源码后发现，cp指令会以一个哈希表跟踪有哪些文件被复制了，这个表需要时常地扩展自身容量以避免太多的冲突。当RAM被耗尽，哈希表的扩容过程会成为性能瓶颈。</p>
<p>我们相信cp的哈希表扩容后，cp指令会继续执行，果然不一会它又“复活”了，但是它会进入周期性的“扩容-拷贝-扩容-拷贝”的循环中，且扩容的<br>时间变得越来越长。经过10天的拷贝，根据dd结果，新文件系统的块数量和inode节点的数量已经和原系统一样，但是让人吃惊的是cp指令并没有退出。</p>
<p>再次阅读源码，我发现cp正在认真地解构哈希表（使用forget_all函数），由于cp进程需要的虚拟内存大小达到了17GB+，但服务器总共才10G内存，所以解构过程执行了很多RAM和swap区间的换页操作。</p>
<p>上面整个过程中，我使用了cp的-v选项，并使用tee把日志重定向到日志文件（很大的文件）中。cp的输出信息会被缓存，为使这些缓存信息全部刷新到日志文件中，我给了cp多于一天的时间进行解构哈希表。</p>
<p>运行”ls –laR”指令，查看下两个文件系统中的文件是否一致，发现除了日志文件的一些错误外，只有一个文件发生了io错误（还好，我们有它的另一个备份）。</p>
<p>这种错误不会马上复现，但是如果cp能够设计一种数据结构，在等待io的时候处理那些已经被记录的文件，那样处理效率会更高。此外，对于cp最后解<br>构哈希表的forget_all函数，除了那些缺少可用内存管理模块的老式服务器一定需要它之外，我还没发现去掉这个函数会对整个拷贝过程产生什么不好的影响。</p>
<p>总结一下：</p>
<p>1、拷贝整个文件系统时，如果确定你的硬件和文件系统都OK，应该使用块级别的拷贝。这种拷贝方式更快，除非你有许多空闲块，但是无论如何它耗费的内存都是较少的；</p>
<p>2、如果要拷贝许多文件，并想要保留硬链接的信息，可以采用文件级拷贝。拷贝之前需要保证机器有足够多的内存；</p>
<p>3、比起简单粗暴地停止进程，认真地解构数据结构会花费更多的时间；</p>
<p>4、告警的硬盘的数量并不等同于有坏块的硬盘的数量。如果不走运，就算配置了RAID6，没来得及等3块磁盘告警，你的数据可能已经丢失。这个时候我们只能赌一把了。同样的情况适用于RAID 5，那怕只有一块磁盘甚至没有磁盘告警，如果不走运，你的数据照样丢！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/13/用cp命令复制大量文件/" data-id="ciwpzcd6r0042xjcyt30t3t7n" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/9/">&laquo; __('prev')</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><a class="page-number" href="/page/12/">12</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><a class="extend next" rel="next" href="/page/11/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/12/15/CentOS-6-x-安装SVN/">CentOS 6.x 安装SVN</a>
          </li>
        
          <li>
            <a href="/2016/12/15/CentOS-7-x-git/">CentOS 7.x git</a>
          </li>
        
          <li>
            <a href="/2016/12/15/开源资源/">开源资源</a>
          </li>
        
          <li>
            <a href="/2016/12/15/开源软件/">开源软件</a>
          </li>
        
          <li>
            <a href="/2016/12/15/Twitter-开源软件/">Twitter 开源软件</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 JinYan<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>