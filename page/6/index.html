<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>SanYuan</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="SanYuan">
<meta property="og:url" content="http://yoursite.com/page/6/index.html">
<meta property="og:site_name" content="SanYuan">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="SanYuan">
  
    <link rel="alternate" href="/atom.xml" title="SanYuan" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">SanYuan</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-xargs" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/13/xargs/" class="article-date">
  <time datetime="2016-12-13T00:50:36.000Z" itemprop="datePublished">2016-12-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/13/xargs/">xargs</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>xargs 命令行参数转换</p>
<p>xargs 能够将输入数据转化为特定命令的命令行参数；这样，可以配合很多命令来组合使用。比如grep，比如find；</p>
<p>将多行输出转化为单行输出<br>cat file.txt| xargs<br>\n 是多行文本间的定界符</p>
<p>将单行转化为多行输出<br>cat single.txt | xargs -n 3<br>-n：指定每行显示的字段数</p>
<p>xargs参数说明</p>
<p>-d 定义定界符 （默认为空格 多行的定界符为 \n）<br>-n 指定输出为多行<br>-I {} 指定替换字符串，这个字符串在xargs扩展时会被替换掉,用于待执行的命令需要多个参数时<br>eg：</p>
<p>cat file.txt | xargs -I {} ./command.sh -p {} -1</p>
<p>-0：指定\0为输入定界符<br>eg：统计程序行数</p>
<p>find source_dir/ -type f -name “*.cpp” -print0 |xargs -0 wc -l</p>
<p>忽略头x个词</p>
<p>我对xargs很着迷，我感觉它就像一把快刀。但有时候用它获得的结果需要调整一下，也许需要取得一些值。例如，你想去掉下面文件影像里的一些信息：<br>function skip {<br>n=$(($1 + 1))<br>cut -d’ ‘ -f$n-<br>}<br>下面是如何使用它：</p>
<p>●使用 docker images 得到下面的输出：<br>$ docker images</p>
<p>REPOSITORY                   TAG         IMAGE ID            CREATED             VIRTUAL SIZE</p>
<p><none>                       <none>      65a9e3ef7171        3 weeks ago         1.592 GB</none></none></p>
<p><none>                       <none>      7c01ca6c30f2        3 weeks ago         11.1 MB</none></none></p>
<p><none>                       <none>      9518620e6a0e        3 weeks ago         7.426 MB</none></none></p>
<p><none>                       <none>      430707ee7fe8        3 weeks ago         7.426 MB<br>boot2docker/boot2docker      latest      1dbd7ebffe31        3 weeks ago         1.592 GB<br>spaceghost/tinycore-x86_64   5.4         f47686df00df        7 weeks ago         11.1 MB<br>durdn/bithub                 latest      df1e39df8dbf        8 weeks ago         100.9 MB</none></none></p>
<p><none>                       <none>      c5e6cf38d985        8 weeks ago         100.9 MB<br>nginx                        latest      e426f6ef897e        12 weeks ago        100.2 MB<br>zoobab/tinycore-x64          latest      8cdd417ec611        8 months ago        7.426 MB<br>scratch                      latest      511136ea3c5a        20 months ago       0 B<br>●使用上面的函数，你可以获取所有的IDs：<br>$ docker images | col 3</none></none></p>
<p>IMAGE<br>65a9e3ef7171<br>7c01ca6c30f2<br>9518620e6a0e<br>430707ee7fe8<br>1dbd7ebffe31<br>f47686df00df<br>df1e39df8dbf<br>c5e6cf38d985<br>e426f6ef897e<br>8cdd417ec611<br>511136ea3c5a<br>●进一步处理：<br>docker images | col 3 | xargs</p>
<p>IMAGE 65a9e3ef7171 7c01ca6c30f2 9518620e6a0e 430707ee7fe8 1dbd7ebffe31 f47686df00df df1e39df8dbf c5e6cf38d985 e426f6ef897e 8cdd417ec611 511136ea3c5a<br>●但前面的”IMAGE”字符我也想去掉：<br>docker images | col 3 | xargs | skip 1</p>
<p>65a9e3ef7171 7c01ca6c30f2 9518620e6a0e 430707ee7fe8 1dbd7ebffe31 f47686df00df df1e39df8dbf c5e6cf38d985 e426f6ef897e 8cdd417ec611 511136ea3c5a<br>●完整的写下来就是这样：<br>docker rmi $(docker images | col 3 | xargs | skip 1)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/13/xargs/" data-id="ciwognsz3001gqpcynv6ciqdw" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-sort" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/13/sort/" class="article-date">
  <time datetime="2016-12-13T00:49:54.000Z" itemprop="datePublished">2016-12-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/13/sort/">sort</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>sort 排序</p>
<p>字段说明：<br>-n 按数字进行排序 VS -d 按字典序进行排序<br>-r 逆序排序<br>-k N 指定按第N列排序<br>eg：</p>
<p>sort -nrk 1 data.txt<br>sort -bd data // 忽略像空格之类的前导空白字符</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/13/sort/" data-id="ciwognsyu0017qpcy5zcfgron" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-tr" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/13/tr/" class="article-date">
  <time datetime="2016-12-13T00:48:21.000Z" itemprop="datePublished">2016-12-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/13/tr/">tr</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>用tr进行转换</p>
<p>通用用法</p>
<p>  echo 12345 | tr ‘0-9’ ‘9876543210’ //加解密转换，替换对应字符<br>  cat text| tr ‘\t’ ‘ ‘  //制表符转空格</p>
<p>tr删除字符</p>
<p>  cat file | tr -d ‘0-9’ // 删除所有数字</p>
<p>-c 求补集</p>
<p>  cat file | tr -c ‘0-9’ //获取文件中所有数字<br>  cat file | tr -d -c ‘0-9 \n’  //删除非数字数据</p>
<p>tr压缩字符<br>tr -s 压缩文本中出现的重复字符；最常用于压缩多余的空格</p>
<p>  cat file | tr -s ‘ ‘</p>
<p>字符类<br>tr中可用各种字符类：<br>alnum：字母和数字<br>alpha：字母<br>digit：数字<br>space：空白字符<br>lower：小写<br>upper：大写<br>cntrl：控制（非可打印）字符<br>print：可打印字符<br>使用方法：tr [:class:] [:class:]</p>
<p>  eg: tr ‘[:lower:]’ ‘[:upper:]’</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/13/tr/" data-id="ciwognsyx001aqpcywba8iirn" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-paste" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/13/paste/" class="article-date">
  <time datetime="2016-12-13T00:47:15.000Z" itemprop="datePublished">2016-12-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/13/paste/">paste</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>paste 按列拼接文本</p>
<p>将两个文本按列拼接到一起;</p>
<p>cat file1<br>1<br>2</p>
<p>cat file2<br>colin<br>book</p>
<p>paste file1 file2<br>1 colin<br>2 book</p>
<p>默认的定界符是制表符，可以用-d指明定界符<br>paste file1 file2 -d “,”<br>1,colin<br>2,book</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/13/paste/" data-id="ciwognsyp0013qpcyn1kjg3yr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-wc" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/12/wc/" class="article-date">
  <time datetime="2016-12-12T09:21:24.000Z" itemprop="datePublished">2016-12-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/12/wc/">wc</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>wc 统计行和字符的工具</p>
<p>wc -l file // 统计行数<br>wc -w file // 统计单词数<br>wc -c file // 统计字符数</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/12/wc/" data-id="ciwognsz2001fqpcy0q7mwtkb" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-cat" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/12/cat/" class="article-date">
  <time datetime="2016-12-12T09:20:40.000Z" itemprop="datePublished">2016-12-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/12/cat/">cat</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>用命令行往配置文件里插入多行文本</p>
<p>这种方法非常简单，很多人都知道，下面就是如何用命令行将(&gt;&gt;)多行文本插入一个文件中。这里使用的是“here document”语法，它能让你通过块文本符号来将段落插入文件中，通常用的符合是EOF(意思是 “End Of File”):<br>cat &gt;&gt; path/to/file/to/append-to.txt &lt;&lt; “EOF”<br>export PATH=$HOME/jdk1.8.0_31/bin:$PATH<br>export JAVA_HOME=$HOME/jdk1.8.0_31/<br>EOF<br>两个”EOF“之间的所有内容都会被添加到文件中。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/12/cat/" data-id="ciwognsyd000vqpcy0mkquojc" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Bashmarks" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/12/Bashmarks/" class="article-date">
  <time datetime="2016-12-12T09:19:35.000Z" itemprop="datePublished">2016-12-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/12/Bashmarks/">Bashmarks</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>你还没有在.bashrc里使用bashmarks吗？还在等待什么？它真的非常有用。它能帮你保持历史操作，跳回到你经常使用的目录。下面是我的配置文件里脚本，但我想上面的链接能提供你更多技巧：</p>
<h1 id="USAGE"><a href="#USAGE" class="headerlink" title="USAGE:"></a>USAGE:</h1><h1 id="s-bookmarkname-saves-the-curr-dir-as-bookmarkname"><a href="#s-bookmarkname-saves-the-curr-dir-as-bookmarkname" class="headerlink" title="s bookmarkname - saves the curr dir as bookmarkname"></a>s bookmarkname - saves the curr dir as bookmarkname</h1><h1 id="g-bookmarkname-jumps-to-the-that-bookmark"><a href="#g-bookmarkname-jumps-to-the-that-bookmark" class="headerlink" title="g bookmarkname - jumps to the that bookmark"></a>g bookmarkname - jumps to the that bookmark</h1><h1 id="g-b-TAB-tab-completion-is-available"><a href="#g-b-TAB-tab-completion-is-available" class="headerlink" title="g b[TAB] - tab completion is available"></a>g b[TAB] - tab completion is available</h1><h1 id="l-list-all-bookmarks"><a href="#l-list-all-bookmarks" class="headerlink" title="l - list all bookmarks"></a>l - list all bookmarks</h1><h1 id="save-current-directory-to-bookmarks"><a href="#save-current-directory-to-bookmarks" class="headerlink" title="save current directory to bookmarks"></a>save current directory to bookmarks</h1><p>touch ~/.sdirs<br>function s {<br>cat ~/.sdirs | grep -v “export DIR<em>$1=” &gt; ~/.sdirs1<br>mv ~/.sdirs1 ~/.sdirs<br>echo “export DIR</em>$1=$PWD” &gt;&gt; ~/.sdirs<br>}</p>
<h1 id="jump-to-bookmark"><a href="#jump-to-bookmark" class="headerlink" title="jump to bookmark"></a>jump to bookmark</h1><p>function g {<br>source ~/.sdirs<br>cd $(eval $(echo echo $(echo \$DIR_$1)))<br>}</p>
<h1 id="list-bookmarks-with-dirnam"><a href="#list-bookmarks-with-dirnam" class="headerlink" title="list bookmarks with dirnam"></a>list bookmarks with dirnam</h1><p>function l {<br>source ~/.sdirs<br>env | grep “^DIR_” | cut -c5- | grep “^.*=”<br>}</p>
<h1 id="list-bookmarks-without-dirname"><a href="#list-bookmarks-without-dirname" class="headerlink" title="list bookmarks without dirname"></a>list bookmarks without dirname</h1><p>function <em>l {<br>source ~/.sdirs<br>env | grep “^DIR</em>“ | cut -c5- | grep “^.*=” | cut -f1 -d “=”<br>}</p>
<h1 id="completion-command-for-g"><a href="#completion-command-for-g" class="headerlink" title="completion command for g"></a>completion command for g</h1><p>function _gcomp {<br>local curw<br>COMPREPLY=()<br>curw=${COMP_WORDS[COMP_CWORD]}<br>COMPREPLY=($(compgen -W ‘<code>_l</code>‘ – $curw))<br>return 0<br>}</p>
<h1 id="bind-completion-command-for-g-to-gcomp"><a href="#bind-completion-command-for-g-to-gcomp" class="headerlink" title="bind completion command for g to _gcomp"></a>bind completion command for g to _gcomp</h1><p>complete -F _gcomp g</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/12/Bashmarks/" data-id="ciwognswx0000qpcyr5m915ze" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-使用Linux命令行测试网速" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/12/使用Linux命令行测试网速/" class="article-date">
  <time datetime="2016-12-12T09:17:25.000Z" itemprop="datePublished">2016-12-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/12/使用Linux命令行测试网速/">使用Linux命令行测试网速</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>当发现上网速度变慢时，人们通常会先首先测试自己的电脑到网络服务提供商（通常被称为“最后一公里”）的网络连接速度。在可用于测试宽带速度的网站中，Speedtest.net也许是使用最广泛的。</p>
<p>Speedtest.net的工作原理并不复杂：它在你的浏览器中加载JavaScript代码并自动检测离你最近的Speedtest.net服务器，然后向服务器发送HTTP GET and POST请求来测试上行/下行网速。</p>
<p>但在没有图形化桌面时（例如，当你通过命令行远程登陆服务器或使用没有图形界面的操作系统），基于flash、界面友好的Speedtest.net将无法工作。幸运的是，Speedtest.net提供了一个命令行版本——speedtest-cli。下面我将向你演示如何在Linux的命令行中使用speedtest-cli来测试宽带连接速度。</p>
<p>安装speedtest-cli</p>
<p>speedtest-cli是一个用Python编写的轻量级Linux命令行工具，在Python2.4至3.4版本下均可运行。它基于Speedtest.net的基础架构来测量网络的上/下行速率。安装speedtest-cli很简单——只需要下载其Python脚本文件。</p>
<p>$ wget <a href="https://raw.github.com/sivel/speedtest-cli/master/speedtest_cli.py" target="_blank" rel="external">https://raw.github.com/sivel/speedtest-cli/master/speedtest_cli.py</a><br>$ chmod a+rx speedtest_cli.py<br>$ sudo mv speedtest_cli.py /usr/local/bin/speedtest-cli<br>$ sudo chown root:root /usr/local/bin/speedtest-cli</p>
<p>使用speedtest-cli测试网速</p>
<p>使用speedtest-cli命令也很简单，它不需要任何参数即可工作。</p>
<p>$ speedtest-cli</p>
<p>输入这个命令后，它会自动发现离你最近的Speedtest.net服务器（地理距离），然后打印出测试的网络上/下行速率。</p>
<p>如果你愿意分享测试结果，你可以使用参数“–share”。它将会把你的测试结果上传到Speedtest.net服务器并以图形的方式分享给其他人。</p>
<p>下面是一幅由speedtest-cli自动生成并上传到Speedtest.net的测试结果：</p>
<p>如果你对目前所有可用的Speedtest.net服务器感兴趣，你可以使用参数“–list”。它会打印出所有的Speedtest.net服务器（按照离你的地理距离由近及远排序）。</p>
<p>在上面的列表中，每个服务器的前面都有一个与其对应的ID。如果想使用指定的服务器来测试你的网速，你只需要在speedtest-cli命令后指定其ID即可。例如，如果想使用在Washington DC的服务器，你只需要指定相对应的服务器ID（如935）。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/12/使用Linux命令行测试网速/" data-id="ciwognszb001pqpcy8wwxc9ik" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-给rm命令加上回收站功能" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/12/给rm命令加上回收站功能/" class="article-date">
  <time datetime="2016-12-12T09:11:01.000Z" itemprop="datePublished">2016-12-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/12/给rm命令加上回收站功能/">给rm命令加上回收站功能</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>给rm命令加上回收站功能</p>
<p>背景：<br>在群里，总会有人聊到曾经做过的最坑的事情，其中当然少不了rm命令，比如最出名的rm -rf /*命令。<br>受HDFS回收站机制的启发，我即兴的写了一个shell脚本来实现类似的功能。</p>
<p>具体配置：<br>[dong@localhost ~]$ sudo touch /usr/bin/delete<br>[dong@localhost ~]$ sudo chmod +x /usr/bin/delete<br>[dong@localhost ~]$ sudo vim /usr/bin/delete</p>
<p>#!/bin/bash</p>
<p>trash_dir=${HOME}/.Trash/$(date +%Y%m%d%H%M%S)</p>
<p>function move_item(){<br>  item=$1<br>  full_path=$2<br>  full_dir=$(dirname ${full_path})<br>  mkdir -p ${trash_dir}${full_dir}<br>  mv ${item} ${trash_dir}${full_path}<br>  if [[ $? -eq 0 ]]; then<br>    echo “Moved ${item} to ${trash_dir}${full_path}”<br>  fi<br>}</p>
<p>if [[ $# -eq 0 ]] || $(echo “$1” |grep -Ewq ‘-h|--help’); then<br>  echo “${0} [-f] [*|FILE]”<br>  exit 2<br>fi</p>
<p>for item in $@; do<br>  if $(echo ${item} |grep -vq ‘^-‘); then<br>    if $(echo ${item} |grep -q ‘^/‘); then<br>      full_path=${item}<br>    else<br>      full_path=$(pwd)/${item}<br>    fi<br>    if $(echo $@ |grep -Ewq ‘-f|-rf|-fr’); then<br>      move_item ${item} ${full_path}<br>    else<br>      echo -n “Move ${item} to ${trash_dir}${full_path}? [y/n] “<br>      read yorn<br>      if $(echo ${yorn} |grep -Ewq ‘y|Y|yes|YES’); then<br>        move_item ${item} ${full_path}<br>      fi<br>    fi<br>  fi<br>done</p>
<p>#!/bin/bash</p>
<p>trash_dir=${HOME}/.Trash/$(date +%Y%m%d%H%M%S)</p>
<p>function move_item(){<br>  item=$1<br>  full_path=$2<br>  full_dir=$(dirname ${full_path})<br>  mkdir -p ${trash_dir}${full_dir}<br>  mv ${item} ${trash_dir}${full_path}<br>  if [[ $? -eq 0 ]]; then<br>    echo “Moved ${item} to ${trash_dir}${full_path}”<br>  fi<br>}</p>
<p>if [[ $# -eq 0 ]] || $(echo “$1” |grep -Ewq ‘-h|--help’); then<br>  echo “${0} [-f] [*|FILE]”<br>  exit 2<br>fi</p>
<p>for item in $@; do<br>  if $(echo ${item} |grep -vq ‘^-‘); then<br>    if $(echo ${item} |grep -q ‘^/‘); then<br>      full_path=${item}<br>    else<br>      full_path=$(pwd)/${item}<br>    fi<br>    if $(echo $@ |grep -Ewq ‘-f|-rf|-fr’); then<br>      move_item ${item} ${full_path}<br>    else<br>      echo -n “Move ${item} to ${trash_dir}${full_path}? [y/n] “<br>      read yorn<br>      if $(echo ${yorn} |grep -Ewq ‘y|Y|yes|YES’); then<br>        move_item ${item} ${full_path}<br>      fi<br>    fi<br>  fi<br>done<br>[dong@localhost ~]$ mkdir tmp<br>[dong@localhost ~]$ cd tmp<br>[dong@localhost tmp]$ mkdir 1 2 3<br>[dong@localhost tmp]$ echo 1 &gt; 1/1.txt<br>[dong@localhost tmp]$ echo 2 &gt; 2/2.txt<br>[dong@localhost tmp]$ echo 3 &gt; 3/3.txt<br>[dong@localhost tmp]$ touch a b c<br>[dong@localhost tmp]$ ln -s a d<br>[dong@localhost tmp]$ delete 1</p>
<p>1<br>Move 1 to /home/dong/.Trash/20160415114210/home/dong/tmp/1? [y/n] y<br>2<br>Moved 1 to /home/dong/.Trash/20160415114210/home/dong/tmp/1<br>[dong@localhost tmp]$ delete -f *</p>
<p>1<br>Moved 2 to /home/dong/.Trash/20160415114217/home/dong/tmp/2<br>2<br>Moved 3 to /home/dong/.Trash/20160415114217/home/dong/tmp/3<br>3<br>Moved a to /home/dong/.Trash/20160415114217/home/dong/tmp/a<br>4<br>Moved b to /home/dong/.Trash/20160415114217/home/dong/tmp/b<br>5<br>Moved c to /home/dong/.Trash/20160415114217/home/dong/tmp/c<br>6<br>Moved d to /home/dong/.Trash/20160415114217/home/dong/tmp/d<br>move, rm</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/12/给rm命令加上回收站功能/" data-id="ciwognt09002qqpcyo0nspgu4" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-linux的ulimit各种限制之深入分析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/12/linux的ulimit各种限制之深入分析/" class="article-date">
  <time datetime="2016-12-12T09:09:27.000Z" itemprop="datePublished">2016-12-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/12/linux的ulimit各种限制之深入分析/">linux的ulimit各种限制之深入分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>一般可以通过ulimit命令或编辑/etc/security/limits.conf重新加载的方式使之生效</p>
<p>通过ulimit比较直接,但只在当前的session有效,limits.conf中可以根据用户和限制项使用户在下次登录中生效.</p>
<p>对于limits.conf的设定是通过pam_limits.so的加载生效的,比如/etc/pam.d/sshd,这样通过ssh登录时会加载limit.<br>又或者在/etc/pam.d/login加载生效.</p>
<p>下面将对各种限制进行分析</p>
<p>core file size          (blocks, -c) 0<br>data seg size           (kbytes, -d) unlimited<br>scheduling priority             (-e) 20 a<br>file size               (blocks, -f) unlimited a<br>pending signals                 (-i) 16382<br>max locked memory       (kbytes, -l) 64 a<br>max memory size         (kbytes, -m) unlimited a<br>open files                      (-n) 1024 a<br>pipe size            (512 bytes, -p) 8<br>POSIX message queues     (bytes, -q) 819200<br>real-time priority              (-r) 0<br>stack size              (kbytes, -s) 8192<br>cpu time               (seconds, -t) unlimited<br>max user processes              (-u) unlimited<br>virtual memory          (kbytes, -v) unlimited<br>file locks                      (-x) unlimited</p>
<p>一)限制进程产生的文件大小(file size)</p>
<p>先来说说ulimit的硬限制和软限制<br>硬限制用-H参数,软限制用-S参数.<br>ulimit -a看到的是软限制,通过ulimit -a -H可以看到硬限制.<br>如果ulimit不限定使用-H或-S,此时它会同时把两类限制都改掉的.<br>软限制可以限制用户/组对资源的使用,硬限制的作用是控制软限制.<br>超级用户和普通用户都可以扩大硬限制,但超级用户可以缩小硬限制,普通用户则不能缩小硬限制.<br>硬限制设定后,设定软限制时只能是小于或等于硬限制.</p>
<p>下面的测试应用于硬限制和软限制.</p>
<p>1)软限制不能超过硬限制<br>在超级用户下,同时修改硬/软限制,使当前会话只能建100KB的文件<br>ulimit -f 100</p>
<p>查看当前创建文件大小的硬限制为100KB<br>ulimit -H -f<br>100</p>
<p>此时限制当前会话的软限制为1000KB,出现不能修改的报错<br>ulimit -S -f 1000<br>-bash: ulimit: file size: cannot modify limit: Invalid argument</p>
<p>2)硬限制不能小于软限制<br>在超级用户下,用户查看当前的软限制,此时为unlmiited<br>ulimit -S -f<br>unlimited</p>
<p>此时修改当前会话创建文件大小的硬限制为1000KB,出现不能修改的报错,说明硬限制不能小于软限制<br>ulimit -H -f 1000<br>-bash: ulimit: file size: cannot modify limit: Invalid argument</p>
<p>如果我们把创建文件大小的软限制改为900KB,此后就可以修改它的硬限制了<br>ulimit -S -f 900<br>ulimit -H -f 1000</p>
<p>3)普通用户只能缩小硬限制,超级用户可以扩大硬限制</p>
<p>用普通用户进入系统<br>su – test</p>
<p>查看创建文件大小的硬限制<br>ulimit -H -f<br>unlimited</p>
<p>此时可以缩小该硬限制<br>ulimit -H -f 1000</p>
<p>但不能扩大该硬限制<br>ulimit -H -f 10000</p>
<p>4)硬限制控制软限制,软限制来限制用户对资源的使用</p>
<p>用软限制限制创建文件的大小为1000KB<br>ulimit -S -f 1000</p>
<p>用硬限制限制创建文件的大小为2000KB<br>ulimit -H -f 2000</p>
<p>创建3MB大小的文件<br>dd if=/dev/zero of=/tmp/test bs=3M count=1<br>File size limit exceeded</p>
<p>查看/tmp/test的大小为1000KB,说明软限制对资源的控制是起决定性作用的.<br>ls -lh /tmp/test<br>-rw-r–r– 1 root root 1000K 2010-10-15 23:04 /tmp/test</p>
<p>file size单位是KB.</p>
<p>二)关于进程优先级的限制(scheduling priority)<br>这里的优先级指NICE值<br>这个值只对普通用户起作用,对超级用户不起作用,这个问题是由于CAP_SYS_NICE造成的.<br>例如调整普通用户可以使用的nice值为-10到20之间.<br>硬限制nice的限制为-15到20之间.<br>ulimit -H -e 35</p>
<p>软限制nice的限制为-10到20之间<br>ulimit -S -e 30</p>
<p>用nice命令,使执行ls的nice值为-10<br>nice -n -10 ls /tmp<br>ssh-BossiP2810  ssh-KITFTp2620  ssh-vIQDXV3333</p>
<p>用nice命令,使执行ls的nice值为-11,此时超过了ulimit对nice的软限制,出现了异常.<br>nice -n -11 ls /tmp<br>nice: cannot set niceness: Permission denied</p>
<p>三)内存锁定值的限制(max locked memory)<br>这个值只对普通用户起作用,对超级用户不起作用,这个问题是由于CAP_IPC_LOCK造成的.<br>linux对内存是分页管理的,这意味着有不需要时,在物理内存的数据会被换到交换区或磁盘上.<br>有需要时会被交换到物理内存,而将数据锁定到物理内存可以避免数据的换入/换出.<br>采用锁定内存有两个理由:<br>1)由于程序设计上需要,比如oracle等软件,就需要将数据锁定到物理内存.<br>2)主要是安全上的需要,比如用户名和密码等等,被交换到swap或磁盘,有泄密的可能,所以一直将其锁定到物理内存.</p>
<p>锁定内存的动作由mlock()函数来完成<br>mlock的原型如下:<br>int mlock(const void *addr,size_t len);</p>
<p>测试程序如下:</p>
<p>#include <stdio.h></stdio.h></p>
<p>#include <sys mman.h=""></sys></p>
<p>int main(int argc, char* argv[])<br>{<br>        int array[2048];</p>
<pre><code>if (mlock((const void *)array, sizeof(array)) == -1) {
        perror(&quot;mlock: &quot;);
        return -1;
}

printf(&quot;success to lock stack mem at: %p, len=%zdn&quot;,
                array, sizeof(array));

if (munlock((const void *)array, sizeof(array)) == -1) {
        perror(&quot;munlock: &quot;);
        return -1;
}

printf(&quot;success to unlock stack mem at: %p, len=%zdn&quot;,
                array, sizeof(array));

return 0;
</code></pre><p>}</p>
<p>gcc mlock_test.c -o mlock_test</p>
<p>上面这个程序,锁定2KB的数据到物理内存中,我们调整ulimit的max locked memory.<br>ulimit -H -l 4<br>ulimit -S -l 1<br>./mlock_test<br>mlock: : Cannot allocate memory</p>
<p>我们放大max locked memory的限制到4KB,可以执行上面的程序了.<br>ulimit -S -l 4<br>./mlock_test<br>success to lock stack mem at: 0x7fff1f039500, len=2048<br>success to unlock stack mem at: 0x7fff1f039500, len=2048</p>
<p>注意:如果调整到3KB也不能执行上面的程序,原因是除了这段代码外,我们还会用其它动态链接库.</p>
<p>四)进程打开文件的限制(open files)</p>
<p>这个值针对所有用户,表示可以在进程中打开的文件数.</p>
<p>例如我们将open files的值改为3<br>ulimit -n 3</p>
<p>此时打开/etc/passwd文件时失败了.<br>cat /etc/passwd<br>-bash: start_pipeline: pgrp pipe: Too many open files<br>-bash: /bin/cat: Too many open files</p>
<p>五)信号可以被挂起的最大数(pending signals)</p>
<p>这个值针对所有用户,表示可以被挂起/阻塞的最大信号数量</p>
<p>我们用以下的程序进行测试,源程序如下:</p>
<p>#include <stdio.h></stdio.h></p>
<p>#include <string.h></string.h></p>
<p>#include <stdlib.h></stdlib.h></p>
<p>#include <signal.h></signal.h></p>
<p>#include <unistd.h></unistd.h></p>
<p>volatile int done = 0;</p>
<p>void handler (int sig)<br>{<br>  const char *str = “handled…n”;<br>  write (1, str, strlen(str));<br>  done = 1;<br>}</p>
<p>void child(void)<br>{<br>  int i;<br>  for (i = 0; i &lt; 3; i++){<br>    kill(getppid(), SIGRTMIN);<br>    printf(“child – BANG!n”);<br>  }<br>  exit (0);<br>}</p>
<p>int main (int argc, char *argv[])<br>{<br>  signal (SIGRTMIN, handler);<br>  sigset_t newset, oldset;</p>
<p>  sigfillset(&amp;newset);<br>  sigprocmask(SIG_BLOCK, &amp;newset, &amp;oldset);</p>
<p>  pid_t pid = fork();<br>  if (pid == 0)<br>  child();</p>
<p>  printf(“parent sleeping n”);</p>
<p>  int r = sleep(3);</p>
<p>  printf(“woke up! r=%dn”, r);</p>
<p>  sigprocmask(SIG_SETMASK, &amp;oldset, NULL);</p>
<p>  while (!done){<br>  };</p>
<p>  printf(“exitingn”);<br>  exit(0);<br>}</p>
<p>编译源程序:<br>gcc test.c -o test</p>
<p>执行程序test,这时子程序发送了三次SIGRTMIN信号,父程序在过3秒后,接收并处理该信号.<br>./test<br>parent sleeping<br>child – BANG!<br>child – BANG!<br>child – BANG!<br>woke up! r=0<br>handled…<br>handled…<br>handled…<br>exiting</p>
<p>注意:这里有采用的是发送实时信号(SIGRTMIN),如:kill(getppid(), SIGRTMIN);<br>如果不是实时信号,则只能接收一次.</p>
<p>如果我们将pending signals值改为2,这里将只能保证挂起两个信号,第三个信号将被忽略.如下:<br>ulimit -i 2<br>./test<br>parent sleeping<br>child – BANG!<br>child – BANG!<br>child – BANG!<br>woke up! r=0<br>handled…<br>handled…<br>exiting</p>
<p>六)可以创建使用POSIX消息队列的最大值,单位为bytes.(POSIX message queues)</p>
<p>我们用下面的程序对POSIX消息队列的限制进行测试,如下:</p>
<p>#include <stdio.h></stdio.h></p>
<p>#include <string.h></string.h></p>
<p>#include <stdlib.h></stdlib.h></p>
<p>#include <unistd.h></unistd.h></p>
<p>#include <mqueue.h></mqueue.h></p>
<p>#include <sys stat.h=""></sys></p>
<p>#include <sys wait.h=""></sys></p>
<p>struct message{<br> char mtext[128];<br>};</p>
<p>int send_msg(int qid, int pri, const char text[])<br>{<br> int r = mq_send(qid, text, strlen(text) + 1,pri);<br> if (r == -1){<br>  perror(“mq_send”);<br> }<br> return r;<br>}</p>
<p>void producer(mqd_t qid)<br>{<br> send_msg(qid, 1, “This is my first message.”);<br> send_msg(qid, 1, “This is my second message.”);</p>
<p> send_msg(qid, 3, “No more messages.”);<br>}</p>
<p>void consumer(mqd_t qid)<br>{<br> struct mq_attr mattr;<br> do{<br>  u_int pri;<br>  struct message msg;<br>  ssize_t len;</p>
<p>  len = mq_receive(qid, (char *)&amp;msg, sizeof(msg), &amp;pri);<br>  if (len == -1){<br>   perror(“mq_receive”);<br>   break;<br>  }<br>  printf(“got pri %d ‘%s’ len=%dn”, pri, msg.mtext, len);</p>
<p>  int r = mq_getattr(qid, &amp;mattr);<br>  if (r == -1){<br>   perror(“mq_getattr”);<br>   break;<br>  }<br> }while(mattr.mq_curmsgs);<br>}</p>
<p>int<br>main (int argc, char *argv[])<br>{<br> struct mq_attr mattr = {<br>  .mq_maxmsg = 10,<br>  .mq_msgsize = sizeof(struct message)<br> };</p>
<p> mqd_t mqid = mq_open(“/myq”,<br>    O_CREAT|O_RDWR,<br>    S_IREAD|S_IWRITE,<br>    &amp;mattr);<br> if (mqid == (mqd_t) -1){<br>  perror(“mq_open”);<br>  exit (1);<br> }</p>
<p> pid_t pid = fork();<br> if (pid == 0){<br>  producer(mqid);<br>  mq_close(mqid);<br>  exit(0);<br> }<br> else<br> {<br>  int status;<br>  wait(&amp;status);<br>  consumer(mqid);<br>  mq_close(mqid);<br> }<br> mq_unlink(“/myq”);<br> return 0;<br>}</p>
<p>编译:<br>gcc test.c -o test</p>
<p>限制POSIX消息队列的最大值为1000个字节<br>ulimit -q 1000</p>
<p>这里我们执行test程序<br>./test<br>mq_open: Cannot allocate memory</p>
<p>程序报告无法分配内存.</p>
<p>用strace来跟踪test的运行过程,在下面一条语句时报错.<br>mq_open(“myq”, O_RDWR|O_CREAT, 0600, {mq_maxmsg=10, mq_msgsize=128}) = -1 ENOMEM (Cannot allocate memory)</p>
<p>{mq_maxmsg=10, mq_msgsize=128}即128*10=1280个字节,说明已经超过了1000个字节的POSIX消息队列限制.</p>
<p>我们将POSIX消息队列的最大值调整为1360时,程序可以运行.<br>ulimit -q 1360<br>./test<br>got pri 3 ‘No more messages.’ len=18<br>got pri 1 ‘This is my first message.’ len=26<br>got pri 1 ‘This is my second message.’ len=27</p>
<p>七)程序占用CPU的时间,单位是秒(cpu time)</p>
<p>我们用下面的代码对程序占用CPU时间的限制进行测试</p>
<p>源程序如下：</p>
<h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <stdio.h></stdio.h></h1><h1 id="include-1"><a href="#include-1" class="headerlink" title="include "></a>include <math.h></math.h></h1><p>int main (void)</p>
<p>{<br>  double pi=M_PI;<br>  double pisqrt;<br>  long i;</p>
<p>  while(1){<br>    pisqrt=sqrt(pi);<br>  }<br>  return 0;<br>}</p>
<p>编译:<br>gcc test.c -o test -lm</p>
<p>运行程序test,程序会一直循环下去,只有通过CTRL+C中断.<br>./test<br>^C</p>
<p>用ulimit将程序占用CPU的时间改为2秒,再运行程序.<br>ulimit -t 2<br>./test<br>Killed</p>
<p>程序最后被kill掉了.</p>
<p>八)限制程序实时优先级的范围,只针对普通用户.(real-time priority)</p>
<p>我们用下面的代码对程序实时优先级的范围进行测试</p>
<p>源程序如下:</p>
<h1 id="include-2"><a href="#include-2" class="headerlink" title="include "></a>include <stdio.h></stdio.h></h1><p>int main (void)</p>
<p>{<br>  int i;<br>  for (i=0;i&lt;6;i++)<br>  {<br>    printf (“%dn”,i);<br>    sleep(1);<br>  }<br>  return 0;<br>}</p>
<p>编译:<br>gcc test.c -o test</p>
<p>切换到普通用户进行测试<br>su – ckhitler</p>
<p>用实时优先级20运行test程序<br>chrt -f 20 ./test<br>chrt: failed to set pid 0’s policy: Operation not permitted</p>
<p>我们用root将ulimit的实时优先级调整为20.再进行测试.<br>su – root<br>ulimit -r 20</p>
<p>切换到普通用户,用实时优先级20运行程序,可以运行这个程序了.<br>su – ckhitler<br>chrt -r 20 ./test<br>0<br>1<br>2<br>3<br>4<br>5</p>
<p>以实时优先级50运行程序,还是报错,说明ulimit的限制起了作用.<br>chrt -r 50 ./test<br>chrt: failed to set pid 0’s policy: Operation not permitted</p>
<p>九)限制程序可以fork的进程数,只对普通用户有效(max user processes)</p>
<p>我们用下面的代码对程序的fork进程数的范围进行测试</p>
<p>源程序如下:</p>
<p>#include <unistd.h></unistd.h></p>
<p>#include <stdio.h><br>int main(void)<br>{<br>  pid_t pid;<br>  int count=0;<br>  while (count&lt;3){<br>    pid=fork();<br>    count++;<br>    printf(“count= %dn”,count);<br>  }<br>  return 0;<br>}</stdio.h></p>
<p>编译:<br>gcc test.c -o test<br>count= 1<br>count= 2<br>count= 3<br>count= 2<br>count= 3<br>count= 1<br>count= 3<br>count= 2<br>count= 3<br>count= 3<br>count= 3<br>count= 2<br>count= 3<br>count= 3</p>
<p>程序fork的进程数成倍的增加,这里是14个进程的输出.除自身外,其它13个进程都是test程序fork出来的.<br>我们将fork的限定到12,如下:<br>ulimit -u 12<br>再次执行test程序,这里只有12个进程的输出.<br>./test<br>count= 1<br>count= 2<br>count= 3<br>count= 1<br>count= 2<br>count= 3<br>count= 2<br>count= 3<br>count= 3<br>count= 2<br>count= 3<br>count= 3<br>count= 3</p>
<p>十)限制core文件的大小(core file size)</p>
<p>我们用下面的代码对程序生成core的大小进行测试</p>
<p>源代码:</p>
<p>#include <stdio.h></stdio.h></p>
<p>static void sub(void);</p>
<p>int main(void)<br>{<br>     sub();<br>     return 0;<br>}</p>
<p>static void sub(void)<br>{<br>     int <em>p = NULL;<br>     printf(“%d”, </em>p);<br>}</p>
<p>编译:<br>gcc -g test.c -o test</p>
<p>运行程序test,出现段错误.<br>./test<br>Segmentation fault (core dumped)</p>
<p>如果在当前目录下没有core文件,我们应该调整ulimit对core的大小进行限制,如果core文件大小在这里指定为0,将不会产生core文件.<br>这里设定core文件大小为10个blocks.注:一个blocks在这里为1024个字节.</p>
<p>ulimit -c 10<br>再次运行这个程序<br>./test<br>Segmentation fault (core dumped)</p>
<p>查看core文件的大小<br>ls -lh core<br>-rw——- 1 root root 12K 2011-03-08 13:54 core</p>
<p>我们设定10个blocks应该是10*1024也不是10KB,为什么它是12KB呢,因为它的递增是4KB.<br>如果调整到14个blocks，我们将最大产生16KB的core文件.</p>
<p>十一)限制进程使用数据段的大小(data seg size)</p>
<p>一般来说这个限制会影响程序调用brk(系统调用)和sbrk(库函数)<br>调用malloc时，如果发现vm不够了就会用brk去内核申请.</p>
<p>限制可以使用最大为1KB的数据段</p>
<p>ulimit -d 1</p>
<p>用norff打开/etc/passwd文件<br>nroff /etc/passwd<br>Segmentation fault</p>
<p>可以用strace来跟踪程序的运行.<br>strace nroff /etc/passwd</p>
<p>打印出如下的结果,证明程序在分配内存时不够用时,调用brk申请新的内存,而由于ulimit的限制,导致申请失败.<br>munmap(0x7fc2abf00000, 104420)          = 0<br>rt_sigprocmask(SIG_BLOCK, NULL, [], 8)  = 0<br>open(“/dev/tty”, O_RDWR|O_NONBLOCK)     = 3<br>close(3)                                = 0<br>brk(0)                                  = 0xf5b000<br>brk(0xf5c000)                           = 0xf5b000<br>brk(0xf5c000)                           = 0xf5b000<br>brk(0xf5c000)                           = 0xf5b000<br>— SIGSEGV (Segmentation fault) @ 0 (0) —<br>+++ killed by SIGSEGV +++<br>Segmentation fault</p>
<p>我们这里用一个测试程序对data segment的限制进行测试.<br>源程序如下:</p>
<p>#include <stdio.h><br>int main()<br>{</stdio.h></p>
<pre><code>int start,end;
start = sbrk(0);
(char *)malloc(32*1024);
end = sbrk(0);
printf(&quot;hello I used %d vmemoryn&quot;,end – start);
return 0;
</code></pre><p>}</p>
<p>gcc test.c -o test<br> ./test<br>hello I used 0 vmemory</p>
<p>通过ulimit将限制改为170KB<br>再次运行程序<br>./test<br>hello I used 167936 vmemory</p>
<p>十二)限制进程使用堆栈段的大小</p>
<p>我们用ulimit将堆栈段的大小调整为16,即16*1024.<br>ulimit -s 16</p>
<p>再运行命令:<br>ls -l /etc/<br>Segmentation fault (core dumped)</p>
<p>这时用strace跟踪命令的运行过程<br>strace ls -l /etc/</p>
<p>发现它调用getrlimit,这里的限制是16<em>1024,不够程序运行时用到的堆栈.<br>getrlimit(RLIMIT_STACK, {rlim_cur=16</em>1024, rlim_max=16*1024}) = 0</p>
<p>注:在2.6.32系统上ls -l /etc/并不会出现堆栈不够用的情况,这时可以用expect来触发这个问题.</p>
<p>如:<br>expect<br>Tcl_Init failed: out of stack space (infinite loop?)</p>
<p>十三)限制进程使用虚拟内存的大小</p>
<p>我们用ulimit将虚拟内存调整为8192KB<br>ulimit -v 8192</p>
<p>运行ls<br>ls<br>ls: error while loading shared libraries: libc.so.6: failed to map segment from shared object: Cannot allocate memory<br>ls在加载libc.so.6动态库的时候报了错,提示内存不足.</p>
<p>用strace跟踪ls的运行过程,看到下面的输出,说明在做mmap映射出内存时,出现内存不够用.<br>mmap(NULL, 3680296, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = -1 ENOMEM (Cannot allocate memory)<br>close(3)                                = 0<br>writev(2, [{“ls”, 2}, {“: “, 2}, {“error while loading shared libra”…, 36}, {“: “, 2}, {“libc.so.6”, 9}, {“: “, 2}, {“failed to map segment from share”…, 40}, {“: “, 2}, {“Cannot allocate memory”, 22}, {“n”, 1}], 10ls: error while loading shared libraries: libc.so.6: failed to map segment from shared object: Cannot allocate memory</p>
<p>十四)剩下的三种ulimit限制说明(file locks/max memory size/pipe size)</p>
<p>文件锁的限制只在2.4内核之前有用.<br>驻留内存的限制在很多系统里也没有作用.<br>管道的缓存不能改变,只能是8*512(bytes),也就是4096个字节.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/12/linux的ulimit各种限制之深入分析/" data-id="ciwognsyl0010qpcylwmpy7h7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/5/">&laquo; __('prev')</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/7/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/12/14/CentOS-6-x-GoAccess/">CentOS 6.x GoAccess</a>
          </li>
        
          <li>
            <a href="/2016/12/14/CentOS-6-x-Logrotate/">CentOS 6.x Logrotate</a>
          </li>
        
          <li>
            <a href="/2016/12/14/CentOS-6-x-Docker-Swarm-Etcd-Cluster/">CentOS 6.x Docker + Swarm + Etcd Cluster</a>
          </li>
        
          <li>
            <a href="/2016/12/14/Ubuntu-14-04-Docker/">Ubuntu 14.04 Docker</a>
          </li>
        
          <li>
            <a href="/2016/12/14/CentOS-6-x-CAT/">CentOS 6.x CAT</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 JinYan<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>