<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>SanYuan</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="SanYuan">
<meta property="og:url" content="http://yoursite.com/page/6/index.html">
<meta property="og:site_name" content="SanYuan">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="SanYuan">
  
    <link rel="alternate" href="/atom.xml" title="SanYuan" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">SanYuan</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-CentOS-7-x-GIT" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/15/CentOS-7-x-GIT/" class="article-date">
  <time datetime="2016-12-15T02:49:00.000Z" itemprop="datePublished">2016-12-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/15/CentOS-7-x-GIT/">CentOS 7.x GIT</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>yum install git -y<br>git -version<br>git –version<br>git config –global user.name sanyuanyanjin<br>git config –global user.email sanyuanyanjin@gmail.com<br>mkdir git_exercise<br>cd git_exercise/<br>git init<br>touch hello.txt<br>git status<br>git add hello.txt<br>git add -A //提交目录下全部<br>git status<br>git commit -m “Initial commit.”</p>
<p>下载远程仓库并合并本地文件<br>[root@CentOS7 ~]# git clone <a href="https://github.com/sanyuanyanjin/gitskills.git" target="_blank" rel="external">https://github.com/sanyuanyanjin/gitskills.git</a><br>正克隆到 ‘gitskills’…<br>remote: Counting objects: 3, done.<br>remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0<br>Unpacking objects: 100% (3/3), done.<br>[root@CentOS7 ~]# cd gitskills/<br>[root@CentOS7 gitskills]#touch hello.txt<br>[root@CentOS7 gitskills]# git status<br>[root@CentOS7 gitskills]# git add -A<br>[root@CentOS7 gitskills]# git status</p>
<h1 id="位于分支-master"><a href="#位于分支-master" class="headerlink" title="位于分支 master"></a>位于分支 master</h1><h1 id="要提交的变更："><a href="#要提交的变更：" class="headerlink" title="要提交的变更："></a>要提交的变更：</h1><h1 id="（使用-“git-reset-HEAD-…”-撤出暂存区）"><a href="#（使用-“git-reset-HEAD-…”-撤出暂存区）" class="headerlink" title="（使用 “git reset HEAD …” 撤出暂存区）"></a>（使用 “git reset HEAD <file>…” 撤出暂存区）</file></h1><p>#</p>
<h1 id="新文件：-hello-txt"><a href="#新文件：-hello-txt" class="headerlink" title="新文件：    hello.txt"></a>新文件：    hello.txt</h1><p>#<br>[root@CentOS7 gitskills]# git commit -m “hello1.”<br>[master 3f0f79c] hello1.<br> 1 file changed, 0 insertions(+), 0 deletions(-)<br> create mode 100644 hello.txt<br>[root@CentOS7 gitskills]# git push origin master<br>Username for ‘<a href="https://github.com" target="_blank" rel="external">https://github.com</a>‘: sanyuanyanjin<br>Password for ‘<a href="https://sanyuanyanjin@github.com" target="_blank" rel="external">https://sanyuanyanjin@github.com</a>‘:<br>Counting objects: 4, done.<br>Delta compression using up to 4 threads.<br>Compressing objects: 100% (2/2), done.<br>Writing objects: 100% (3/3), 274 bytes | 0 bytes/s, done.<br>Total 3 (delta 0), reused 0 (delta 0)<br>To <a href="https://github.com/sanyuanyanjin/gitskills.git" target="_blank" rel="external">https://github.com/sanyuanyanjin/gitskills.git</a><br>   afffd47..3f0f79c  master -&gt; master<br>[root@CentOS7 gitskills]# </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/15/CentOS-7-x-GIT/" data-id="ciwrkt738000t88cy5urvsq02" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-CentOS-7-x-NFS" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/15/CentOS-7-x-NFS/" class="article-date">
  <time datetime="2016-12-15T00:30:48.000Z" itemprop="datePublished">2016-12-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/15/CentOS-7-x-NFS/">CentOS 7.x NFS</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>CentOS 7引入了全新的 systemctl 服务管理，设置和管理服务略有不同。以下是为了提供Mac OS X客户端访问Linux NFS输出的卷实现数据备份的记录，NFS服务器设置见本文，Mac OS X挂载Linux的NFS输出见Mac OS X 挂载Linux卷（NFS）。<br>设置Linux服务端<br>将移动硬盘挂载到 /data 目录<br>mount /dev/sdb1 /data<br>在Paralles Desktop虚拟机运行的是CentOS 7操作系统，使用以下命令安装 NFS 支持<br>yum install nfs-utils nfs-utils-lib<br>设置nfs相关服务在操作系统启动时启动<br>systemctl enable rpcbind<br>systemctl enable nfs-server<br>systemctl enable nfs-lock<br>systemctl enable nfs-idmap<br>启动nfs服务<br>systemctl start rpcbind<br>systemctl start nfs-server<br>systemctl start nfs-lock<br>systemctl start nfs-idmap<br>服务器端设置NFS卷输出，即编辑 /etc/exports 添加：<br>/data    10.211.55.0/24(rw,sync,no_root_squash,no_subtree_check)<br>/data – 共享目录<br>10.211.55.0/24 – 允许访问NFS的客户端IP地址段<br>rw – 允许对共享目录进行读写<br>sync – 实时同步共享目录<br>no_root_squash – 允许root访问<br>no_all_squash - 允许用户授权<br>no_subtree_check - 如果卷的一部分被输出，从客户端发出请求文件的一个常规的调用子目录检查验证卷的相应部分。如果是整个卷输出，禁止这个检查可以加速传输。<br>no_subtree_check - If only part of a volume is exported, a routine called subtree checking verifies that a file that is requested from the client is in the appropriate part of the volume. If the entire volume is exported, disabling this check will speed up transfers. Setting Up an NFS Server<br>NFS客户端挂载<br>Linux挂载NFS的客户端非常简单的命令，先创建挂载目录，然后用 -t nfs 参数挂载就可以了<br>mount -t nfs  10.211.55.9:/data /data<br>如果要设置客户端启动时候就挂载NFS，可以配置 /etc/fstab 添加以下内容<br>10.211.55.9:/data    /data  nfs auto,rw,vers=3,hard,intr,tcp,rsize=32768,wsize=32768      0   0<br>然后在客户端简单使用以下命令就可以挂载<br>mount /data<br>通过防火墙挂载NFS服务<br>在生产环境，可能会因为安全需求在NFS服务器和客户端之间部署防火墙。此时，NFS客户端挂载的时候会有如下输出报错<br>mount.nfs: Connection timed out<br>参考 Running NFS Behind a Firewall 设置防火墙允许访问NFS服务器的服务端口，注意，需要配置NFS服务使用固定端口。<br>MOUNTD_PORT=port</p>
<h1 id="Controls-which-TCP-and-UDP-port-mountd-rpc-mountd-uses"><a href="#Controls-which-TCP-and-UDP-port-mountd-rpc-mountd-uses" class="headerlink" title="Controls which TCP and UDP port mountd (rpc.mountd) uses."></a>Controls which TCP and UDP port mountd (rpc.mountd) uses.</h1><p>STATD_PORT=port</p>
<h1 id="Controls-which-TCP-and-UDP-port-status-rpc-statd-uses"><a href="#Controls-which-TCP-and-UDP-port-status-rpc-statd-uses" class="headerlink" title="Controls which TCP and UDP port status (rpc.statd) uses."></a>Controls which TCP and UDP port status (rpc.statd) uses.</h1><p>LOCKD_TCPPORT=port</p>
<h1 id="Controls-which-TCP-port-nlockmgr-lockd-uses"><a href="#Controls-which-TCP-port-nlockmgr-lockd-uses" class="headerlink" title="Controls which TCP port nlockmgr (lockd) uses."></a>Controls which TCP port nlockmgr (lockd) uses.</h1><p>LOCKD_UDPPORT=port</p>
<h1 id="Controls-which-UDP-port-nlockmgr-lockd-uses"><a href="#Controls-which-UDP-port-nlockmgr-lockd-uses" class="headerlink" title="Controls which UDP port nlockmgr (lockd) uses."></a>Controls which UDP port nlockmgr (lockd) uses.</h1><p>编辑 /etc/sysconfig/nfs 配置文件</p>
<h1 id="TCP-port-rpc-lockd-should-listen-on"><a href="#TCP-port-rpc-lockd-should-listen-on" class="headerlink" title="TCP port rpc.lockd should listen on."></a>TCP port rpc.lockd should listen on.</h1><p>LOCKD_TCPPORT=32803</p>
<h1 id="UDP-port-rpc-lockd-should-listen-on"><a href="#UDP-port-rpc-lockd-should-listen-on" class="headerlink" title="UDP port rpc.lockd should listen on."></a>UDP port rpc.lockd should listen on.</h1><p>LOCKD_UDPPORT=32769<br>MOUNTD_PORT=892<br>STATD_PORT=662<br>可以在Linux NFS服务器上执行以下命令获得NFS端口信息<br>rpcinfo -p<br>需要允许以下端口<br>NFS的TCP和UDP端口2049<br>rpcbind/sunrpc的TCP和UDP端口111<br>设置 MOUNTD_PORT 的TCP和UDP端口<br>设置 STATD_PORT 的TCP和UDP端口<br>设置 LOCKD_TCPPORT 的TCP端口<br>设置 LOCKD_UDPPORT 的UDP端口<br>program vers proto   port  service<br>100000    4   tcp    111  portmapper<br>100000    3   tcp    111  portmapper<br>100000    2   tcp    111  portmapper<br>100000    4   udp    111  portmapper<br>100000    3   udp    111  portmapper<br>100000    2   udp    111  portmapper<br>100024    1   udp  54305  status<br>100024    1   tcp  55604  status<br>100005    1   udp  20048  mountd<br>100005    1   tcp  20048  mountd<br>100005    2   udp  20048  mountd<br>100005    2   tcp  20048  mountd<br>100005    3   udp  20048  mountd<br>100005    3   tcp  20048  mountd<br>100003    3   tcp   2049  nfs<br>100003    4   tcp   2049  nfs<br>100227    3   tcp   2049  nfs_acl<br>100003    3   udp   2049  nfs<br>100003    4   udp   2049  nfs<br>100227    3   udp   2049  nfs_acl<br>100021    1   udp  32769  nlockmgr<br>100021    3   udp  32769  nlockmgr<br>100021    4   udp  32769  nlockmgr<br>100021    1   tcp  32803  nlockmgr<br>100021    3   tcp  32803  nlockmgr<br>100021    4   tcp  32803  nlockmgr<br>100011    1   udp    875  rquotad<br>100011    2   udp    875  rquotad<br>100011    1   tcp    875  rquotad<br>100011    2   tcp    875  rquotad<br>在 Linux NFS 服务器上使用以下命令开启iptables防火墙允许访问以上端口<br>firewall-cmd –permanent –add-port=2049/tcp<br>firewall-cmd –permanent –add-port=2049/udp<br>firewall-cmd –permanent –add-port=111/tcp<br>firewall-cmd –permanent –add-port=111/udp<br>firewall-cmd –permanent –add-port=892/tcp<br>firewall-cmd –permanent –add-port=892/udp<br>firewall-cmd –permanent –add-port=662/tcp<br>firewall-cmd –permanent –add-port=662/udp<br>firewall-cmd –permanent –add-port=32803/tcp<br>firewall-cmd –permanent –add-port=32769/udp<br>在 Linux NFS 服务器上使用以下命令重新加载防火墙规则<br>firewall-cmd –reload</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/15/CentOS-7-x-NFS/" data-id="ciwrkt73b000v88cycxm8kuqh" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-CentOS-7-x-HA-Cluster" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/15/CentOS-7-x-HA-Cluster/" class="article-date">
  <time datetime="2016-12-15T00:27:53.000Z" itemprop="datePublished">2016-12-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/15/CentOS-7-x-HA-Cluster/">CentOS 7.x HA Cluster</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文以两台机器实现双集热备高可用集群，主机名node1的IP为192.168.122.168，主机名node2的IP为192.168.122.169。<br>一、安装集群软件<br>必须软件pcs，pacemaker，corosync，fence-agents-all，如果需要配置相关服务，也要安装对应的软件<br>二、配置防火墙<br>1、禁止防火墙和selinux</p>
<p>#systemctldisablefirewalld</p>
<p>#systemctlstopfirewalld<br>修改/etc/sysconfig/selinux确保SELINUX=disabled，然后执行setenforce0或者reboot服务器以生效<br>2、设置防火墙规则</p>
<p>#firewall-cmd–permanent–add-service=high-availability</p>
<p>#firewall-cmd–add-service=high-availability<br>三、各节点之间主机名互相解析<br>分别修改2台主机名分别为node1和node2，在centos7中直接修改/etc/hostname加入本机主机名和主机表，然后重启网络服务即可。</p>
<p>#vi/etc/hostname<br>node1</p>
<p>#systemctlrestartnetwork.service</p>
<p>#hostname<br>node1<br>配置2台主机的主机表，在/etc/hosts中加入<br>192.168.122.168node1<br>192.168.122.169node2<br>四、各节点之间时间同步<br>在node1和node2分别进行时间同步，可以使用ntp实现。<br>[root@node1~]#ntpdate172.16.0.1//172.16.0.1为时间服务器<br>五、各节点之间配置ssh的无密码密钥访问。<br>下面的操作需要在各个节点上操作。</p>
<p>#ssh-keygen-trsa-P‘’#这个生成一个密码为空的公钥和一个密钥，把公钥复制到对方节点上即可</p>
<p>#ssh-copy-id-i/root/.ssh/id_rsa.pubroot@node2#对方主机名用登录用户名<br>两台主机都要互相可以通信，所以两台主机都得互相生成密钥和复制公钥，相互的节点上的hosts文件是都要解析对方的主机名，192.168.122.168node1192.168.122.169node2</p>
<p>#sshnode2‘date’;date#测试一下是否已经互信<br>六、通过pacemaker来管理高可用集群<br>1、创建集群用户<br>为了有利于各节点之间通信和配置集群，在每个节点上创建一个hacluster的用户，各个节点上的密码必须是同一个。</p>
<p>#passwdhacluster<br>Changingpasswordforuserhacluster.<br>Newpassword:<br>Retypenewpassword:<br>passwd:allauthenticationtokensupdatedsuccessfully.<br>2、设置pcsd开机自启动</p>
<p>#systemctlstartpcsd.service</p>
<p>#systemctlenablepcsd.service<br>3、集群各节点之间进行认证</p>
<p>#pcsclusterauthnode1node2Username:haclusterPassword:node1:Authorizednode2:Authorized<br>4、创建并启动集群<br>[root@z1~]#pcsclustersetup–start–namemy_clusternode1node2<br>node1:Succeeded<br>node1:StartingCluster…<br>node2:Succeeded<br>node2:StartingCluster…<br>5、设置集群自启动</p>
<p>#pcsclusterenable–all<br>6、查看集群状态信息<br>[root@z1~]#pcsclusterstatus<br>7、设置fence设备<br>这个可以参考<redhatenterpriselinux7highavailabilityadd-onreference><br>corosync默认启用了stonith，而当前集群并没有相应的stonith设备，因此此默认配置目前尚不可用，这可以通过如下命令验证：</redhatenterpriselinux7highavailabilityadd-onreference></p>
<p>#crm_verify-L-V<br>可以通过如下面命令禁用stonith：</p>
<p>#pcspropertysetstonith-enabled=false（默认是true）<br>8、配置存储<br>高可用集群既可以使用本地磁盘来构建纯软件的镜像型集群系统，也可以使用专门的共享磁盘装置来构建大规模的共享磁盘型集群系统，充分满足客户的不同需求。<br>共享磁盘主要有iscsi或DBRD。本文并没有使用共享磁盘。<br>9、配置浮点IP<br>不管集群服务在哪运行,我们要一个固定的地址来提供服务。在这里我选择192.168.122.101作为浮动IP,给它取一个好记的名字ClusterIP并且告诉集群每30秒检查它一次。</p>
<p>#pcsresourcecreateVIPocf:heartbeat:IPaddr2ip=192.168.122.170cidr_netmask=24opmonitorinterval=30s</p>
<p>#pcsupdateVIPopmonitorinterval=15s<br>10、配置apache服务<br>在node1和node2上安装httpd，确认httpd开机被禁用</p>
<p>#systemctlstatushttpd.service；<br>配置httpd监控页面（貌似不配置也可以通过systemd监控），分别在node1和node2上执行</p>
<p>#cat&gt;/etc/httpd/conf.d/status.conf<a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#111;&#58;&#60;&#69;&#79;&#70;&#xa;&#83;&#101;&#x74;&#72;&#x61;&#110;&#x64;&#108;&#x65;&#x72;&#115;&#x65;&#114;&#118;&#x65;&#114;&#45;&#x73;&#116;&#97;&#116;&#117;&#x73;&#10;&#x4f;&#x72;&#100;&#101;&#x72;&#100;&#x65;&#110;&#121;&#44;&#x61;&#x6c;&#108;&#x6f;&#119;&#xa;&#x44;&#101;&#x6e;&#121;&#x66;&#114;&#111;&#x6d;&#x61;&#x6c;&#x6c;&#10;&#65;&#108;&#x6c;&#111;&#x77;&#102;&#114;&#111;&#x6d;&#x6c;&#x6f;&#99;&#x61;&#x6c;&#104;&#x6f;&#x73;&#116;&#10;&#69;&#79;&#70;&#xa;&#x9996;&#x5148;&#x6211;&#x4eec;&#x4e3a;&#65;&#112;&#x61;&#x63;&#x68;&#x65;&#21019;&#x5efa;&#x4e00;&#x4e2a;&#x4e3b;&#x9875;&#12290;&#22312;&#x63;&#x65;&#x6e;&#116;&#111;&#x73;&#x4e0a;&#38754;&#40664;&#x8ba4;&#30340;&#65;&#112;&#x61;&#x63;&#x68;&#101;&#100;&#x6f;&#99;&#114;&#x6f;&#111;&#x74;&#26159;&#x2f;&#x76;&#x61;&#114;&#47;&#x77;&#x77;&#119;&#47;&#104;&#x74;&#109;&#108;&#x2c;&#25152;&#x4ee5;&#x6211;&#20204;&#22312;&#x8fd9;&#20010;&#x76ee;&#24405;&#x4e0b;&#x9762;&#x5efa;&#x7acb;&#19968;&#20010;&#20027;&#x9875;&#12290;&#10;&#110;&#111;&#100;&#x65;&#49;&#33410;&#28857;&#20462;&#25913;&#22914;&#19979;&#xff1a;&#xa;&#x5b;&#114;&#111;&#x6f;&#x74;&#64;&#110;&#111;&#100;&#x65;&#x31;&#126;&#93;&#x23;&#x63;&#97;&#116;&#x3c;&#60;&#x2d;&#69;&#78;&#x44;">&#60;&#69;&#79;&#70;&#xa;&#83;&#101;&#x74;&#72;&#x61;&#110;&#x64;&#108;&#x65;&#x72;&#115;&#x65;&#114;&#118;&#x65;&#114;&#45;&#x73;&#116;&#97;&#116;&#117;&#x73;&#10;&#x4f;&#x72;&#100;&#101;&#x72;&#100;&#x65;&#110;&#121;&#44;&#x61;&#x6c;&#108;&#x6f;&#119;&#xa;&#x44;&#101;&#x6e;&#121;&#x66;&#114;&#111;&#x6d;&#x61;&#x6c;&#x6c;&#10;&#65;&#108;&#x6c;&#111;&#x77;&#102;&#114;&#111;&#x6d;&#x6c;&#x6f;&#99;&#x61;&#x6c;&#104;&#x6f;&#x73;&#116;&#10;&#69;&#79;&#70;&#xa;&#x9996;&#x5148;&#x6211;&#x4eec;&#x4e3a;&#65;&#112;&#x61;&#x63;&#x68;&#x65;&#21019;&#x5efa;&#x4e00;&#x4e2a;&#x4e3b;&#x9875;&#12290;&#22312;&#x63;&#x65;&#x6e;&#116;&#111;&#x73;&#x4e0a;&#38754;&#40664;&#x8ba4;&#30340;&#65;&#112;&#x61;&#x63;&#x68;&#101;&#100;&#x6f;&#99;&#114;&#x6f;&#111;&#x74;&#26159;&#x2f;&#x76;&#x61;&#114;&#47;&#x77;&#x77;&#119;&#47;&#104;&#x74;&#109;&#108;&#x2c;&#25152;&#x4ee5;&#x6211;&#20204;&#22312;&#x8fd9;&#20010;&#x76ee;&#24405;&#x4e0b;&#x9762;&#x5efa;&#x7acb;&#19968;&#20010;&#20027;&#x9875;&#12290;&#10;&#110;&#111;&#100;&#x65;&#49;&#33410;&#28857;&#20462;&#25913;&#22914;&#19979;&#xff1a;&#xa;&#x5b;&#114;&#111;&#x6f;&#x74;&#64;&#110;&#111;&#100;&#x65;&#x31;&#126;&#93;&#x23;&#x63;&#97;&#116;&#x3c;&#60;&#x2d;&#69;&#78;&#x44;</a>/var/www/html/index.html</p>
<p><html></html></p>
<p><body>Hellonode1</body><br><br>END<br>node2节点修改如下：<br>[root@node2~]#cat&lt;&lt;-END&gt;/var/www/html/index.html</p>
<p><html></html></p>
<p><body>Hellonode2</body><br><br>END<br>下面语句是将httpd作为资源添加到集群中：</p>
<p>#pcsresourcecreateWEBapacheconfigfile=”/etc/httpd/conf/httpd.conf”statusurl=”<a href="http://127.0.0.1/server-status" target="_blank" rel="external">http://127.0.0.1/server-status</a>“<br>11、创建group<br>将VIP和WEBresource捆绑到这个group中，使之作为一个整体在集群中切换。（此配置为可选)</p>
<p>#pcsresourcegroupaddMyGroupVIP</p>
<p>#pcsresourcegroupaddMyGroupWEB<br>12、配置服务启动顺序<br>以避免出现资源冲突，语法：(pcsresourcegroupadd的时候也可以根据加的顺序依次启动，此配置为可选)</p>
<p>#pcsconstraintorder[action]then[action]</p>
<p>#pcsconstraintorderstartVIPthenstartWEB<br>13、指定优先的Location（此配置为可选)<br>Pacemaker并不要求你机器的硬件配置是相同的,可能某些机器比另外的机器配置要好。这种状况下我们会希望设置:当某个节点可用时,资源就要跑在上面之类的规则。为了达到这个效果我们创建location约束。同样的,我们给他取一个描述性的名字(prefer-node1),指明我们想在上面跑WEB这个服务,多想在上面跑(我们现在指定分值为50,但是在双节点的集群状态下,任何大于0的值都可以达到想要的效果),以及目标节点的名字:</p>
<p>#pcsconstraintlocationWEBprefersnode1=50</p>
<p>#pcsconstraintlocationWEBprefersnode2=45<br>这里指定分值越大，代表越想在对应的节点上运行。<br>14、资源粘性（此配置为可选)<br>一些环境中会要求尽量避免资源在节点之间迁移。迁移资源通常意味着一段时间内无法提供服务，某些复杂的服务，比如Oracle数据库，这个时间可能会很长。<br>为了达到这个效果，Pacemaker有一个叫做“资源粘性值”的概念，它能够控制一个服务(资源)有多想呆在它正在运行的节点上。<br>Pacemaker为了达到最优分布各个资源的目的，默认设置这个值为0。我们可以为每个资源定义不同的粘性值，但一般来说，更改默认粘性值就够了。资源粘性表示资源是否倾向于留在当前节点，如果为正整数，表示倾向，负数则会离开，-inf表示负无穷，inf表示正无穷。</p>
<p>#pcsresourcedefaultsresource-stickiness=100<br>常用命令汇总：<br>查看集群状态：#pcsstatus<br>查看集群当前配置：#pcsconfig<br>开机后集群自启动：#pcsclusterenable–all<br>启动集群：#pcsclusterstart–all<br>查看集群资源状态：#pcsresourceshow<br>验证集群配置情况：#crm_verify-L-V<br>测试资源配置：#pcsresourcedebug-startresource<br>设置节点为备用状态：#pcsclusterstandbynode1</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/15/CentOS-7-x-HA-Cluster/" data-id="ciwrkt73b000u88cykp60alb9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-CentOS-6-x-Puppet" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/15/CentOS-6-x-Puppet/" class="article-date">
  <time datetime="2016-12-15T00:26:00.000Z" itemprop="datePublished">2016-12-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/15/CentOS-6-x-Puppet/">CentOS 6.x Puppet</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>一、Puppet基础原理:<br>Puppet是一款使用GPLV2X协议授权的开源管理配置工具，用ruby语言开发，既可以通过客户端—服务器的方式运行，也可以独立运行。puppet可以为系统管理员提供方便，快捷的系统自动化管理。<br>二、puppet工作流程</p>
<ol>
<li>客户端 puppet-client 向 puppet-master 发起认证请求，或使用带签名的证书。</li>
<li>puppet-master 告诉 puppet-client 是合法的。</li>
<li>puppet-client 调用 facter， Facter 探测出主机的一些变量， 例如主机名、 内存大小、 IP 地址等，puppet-client 将这些信息通过 SSL 连接发送到服务器端。</li>
<li>puppet-master 服务器端检测客户端的主机名，然后找到 manifest 对应的 node 配置，并对该部分内容进行解析。facter 送过来的信息可以作为变量处理，node 牵涉到的代码才解析，其他没牵涉的代码不解析。解析分为几个阶段，首先是语法检查，如果语法错误就报错；如果语法没错，就继续解析，解析的结果生成一个中间的“伪代码”(catelog)，然后把伪代码发给客户端。</li>
<li>puppet-client 端接收到“伪代码”，并且执行。</li>
<li>puppet-client 端在执行时判断有没有 file 文件，如果有，则向 fileserver 发起请求。</li>
<li>puppet-client 端判断有没有配置 report，如果已配置，则把执行结果发送给服务器。</li>
<li>puppet-server 端把 puppet-client 端的执行结果写入日志，并发送给报告系统。<br>三、puppet安装<br>1、直接通过yum安装老系统自带版本。<br>yum install puppet -y<br>2、安装最新版本<br>sudo rpm -ivh <a href="https://yum.puppetlabs.com/puppetlabs-release-el-6.noarch.rpm" target="_blank" rel="external">https://yum.puppetlabs.com/puppetlabs-release-el-6.noarch.rpm</a><br>2.1、安装puppet-server。<br>sudo puppet resource package puppet-server ensure=latest<br>2.2、安装agent<br>sudo puppet resource package puppet ensure=latest<br>四、puppet资源管理<br>Puppet中的资源是puppet工具的核心，它是通过puppet管理配置系统的最小单位。<br>..<br>1、查看资源类型<br>puppet describe -l<br>2、查看资源摘要<br>puppet describe -s <resource_name><br>3、查看资源详细用法<br>puppet describe <resource_name><br>4、资源的基本格式<br>资源名 { ‘标题’:<pre><code>属性1 =&gt; &apos;值&apos;,
属性2 =&gt; &apos;值&apos;,
</code></pre>}<br>`<blockquote>
<p>以安装httpd为例<br>``` cpp<br>package { ‘httpd’:</p>
<pre><code>ensure =&gt; &apos;present&apos;,
provider =&gt; &apos;rpm&apos;,
</code></pre><p>}<br>puppet常用资源:file,filebucket,host,group,package,service,exec,cron,notify 等。<br>..<br>5、资源公有属性:<br>before :指明资源要在某个资源之前运行<br>require：指明某个资源要在某个资源之后运行。<br>notify: 主动通知其他资源，本资源的状态<br>subscibe ：被动通知，当它检测到资源状态发生改变的时候，主动更新所在资源状态。<br>还可以使用<br>-&gt; 表示资源前后关系<br>~&gt; 表示资源之间的通知<br>五、puppet语言<br>1)、puppet变量：<br>1、名称之前必须以$开头，赋值用=，支持追加赋值+=；<br>2、变量名称有两种格式，简短名称，FQN($scope::variable)。</p>
<pre><code>$webserver = &quot;httpd&quot;
package {&quot;httpd&quot;:
       ensure =&gt; &quot;present&quot;,
       name =&gt; $webserver
} 
</code></pre><p>3、作用域:top &gt; node &gt; local 作用域越小，优先级越高<br>2)、数据类型：</p>
<pre><code>1、直接字串
       可以使用引号，也可以不用。
       换行符为\n,windows中\r\n
2、布尔型
       true,false
       其它类型会自动转换为布尔型。
       所有数字都是true
       空字符串为false，其它字符串为true
3、数值
       整数
       浮点数
4、数组，逗号隔开
       $array = [&apos;httpd&apos;,&apos;mysql&apos;,&apos;php&apos;]
       package {$array:ensure =&gt; installed} #依次安装包
5、hash
       { key1 =&gt; value1,key2 =&gt; value2,…}
6、undef，声明未定义的东西不能加上引号的。
</code></pre><p>3)、puppet支持的操作符和对应的表达式：</p>
<h1 id="比较操作符"><a href="#比较操作符" class="headerlink" title="比较操作符:"></a>比较操作符:</h1><pre><code>！=
&lt;,&gt;,&lt;=,&gt;=,
=~ 正则匹配
!~ 正则不匹配
in
</code></pre><p>布尔操作符:</p>
<pre><code>and
or
!
</code></pre><p>算术运算</p>
<pre><code>+
–
 /
 *
 &lt;&lt;   左移
</code></pre><blockquote>
<p>  右移</p>
<pre><code>$osfamily == &apos;CentOS&apos; 
$kernel in [&apos;Linux&apos;,&apos;solaris&apos;,&apos;freebsd&apos;]
</code></pre><p>4)、puppet的条件判断语句：</p>
<pre><code>if ..elsif..else
case
selector语句 #意思是在两个选项中任选其中一个赋值
</code></pre><p>if $operationsystem == ‘CentOS’{</p>
<pre><code>       notice(&quot;welcome to CentOS&quot;)
}
elsif $operationsystem == &apos;Redhat&apos; {
       notice(&quot;Welcome to Redhat&quot;)
}
elsif $operationsystem == &apos;Fedora&apos; {
       notice(&quot;Welcome to Fedora&quot;)
}
else{
       notice(&apos;Welcome to ET&apos;)
}
</code></pre><p>case $operationsystem {</p>
<pre><code>&apos;Solaris&apos;:  { include role::solaris }
&apos;Redhat&apos;,&apos;CentOS&apos; : { include role::redhat }
/^(Debian|Ubuntu)$/ : { include role::debian }
default : { include role::generic }
</code></pre><p>}<br>$webserver = $operatingsystem ? {</p>
<pre><code>/(?i-mx:&apos;ubuntu&apos;|debian)/ =&gt; &apos;apache&apos;,
/(?i-mx:redhat|centos|fedora)/ =&gt; &apos;httpd&apos;,
default =&gt; &apos;httpd&apos;
</code></pre><p>}<br>i：表示忽略大小写</p>
</blockquote>
</blockquote>
</resource_name></resource_name></li>
</ol>
<ul>
<li>： 表示不使用某转移符号<br>m：表示把 “.” 当做换行符使用<br>x :表示互略模式中空白字符和注释。<br>六、puppet类和模块<br>类是具有相同特性和行为的集合。就是一组代码块，在需要时可以通过名称进行调用。只定义类，并不会调用，需要声明才可以。<br>1)、语法：<br>class class_name [inherits] [base_class] {<pre><code>正常的puppet代码
</code></pre>}<br>如果在同个模块定义了多个类， 可以采双冒号（ ：： ） 。<br>例如定义个nginx模块，<br>模块中 定义三个类：<br>class nginx { … }<br>class nginx::config { … }<br>class nginx::vhost { … }<br>2)、类的继承(基类不能有参数)：<br>1、继承资源属性<br>2、覆盖资源属性<pre><code>=&gt;         
</code></pre>3、追加资源属性<pre><code>+&gt;
</code></pre>3)、 模块<br>模块结构<br>module name<pre><code>mainfests
       init.pp  #必须至少声明一个类。类与模块名相同
       *.pp
        # mudule_name::[subdirname]::mainfect_name
files：包含的是一个静态文件。puppet的agentmaster模型。
       puppet:///modles/module_name/[subdir_name/]file_name
templates：模板文件 *.erb 用到ruby语言
       template(&apos;&apos;);
       content =&gt; template(&apos;模板文件&apos;),
lib #插件目录。
tests ：当前模块的使用帮助或者实例文件
spec ：为lib目录的插件提供使用说明，范例的。
</code></pre>七、事例，puppet部署LNMP<br>1、假定已经安装好puppet-server。<br>..<br>2、主机名通信<br>cat &gt;&gt; /etc/hosts &lt;&lt;EOF192.168.198.139 puppet-server192.168.198.160 puppet-client<br>EOF<br>3、提供puppet文件<br>mkdir /etc/puppet/modules/lnmp/{manifests,files,templates,tests} -p<br>vim /etc/puppet/modules/lnmp/manifests/init.pp<br>class lnmp {<pre><code>include lnmp::nginx
include lnmp::mysql
include lnmp::php
</code></pre>}<br>vim /etc/puppet/modules/lnmp/manifests/nginx.pp<br>class lnmp::nginx {<br>  package{‘nginx’:<pre><code>ensure  =&gt; present,
name    =&gt; nginx,
</code></pre>  }<br>  file{‘nginx.conf’:<pre><code>ensure  =&gt; file,
source  =&gt; &apos;puppet:///modules/lnmp/nginx.conf&apos;,
path    =&gt; &apos;/etc/nginx/nginx.conf&apos;,
require =&gt; Package[&apos;nginx&apos;],
</code></pre>  }<br> service{‘nginx’:<pre><code>ensure  =&gt; true,
enable  =&gt; true,
subscribe =&gt; File[&apos;nginx.conf&apos;],
</code></pre>  }<br>}<br>vim /etc/puppet/modules/lnmp/manifests/php.pp<br>class lnmp::php {<br>  package{‘php-fpm’:<pre><code>ensure  =&gt; present,
name    =&gt; php-fpm,
</code></pre>  }<br>  file{‘www.conf’:<pre><code>ensure  =&gt; file,
source  =&gt; &apos;puppet:///modules/lnmp/www.conf&apos;,
path    =&gt; &apos;/etc/php-fpm.d/www.conf&apos;,
require =&gt; Package[&apos;php-fpm&apos;],
</code></pre>  }<br> service{‘php-fpm’:<pre><code>ensure  =&gt; true,
enable  =&gt; true,
subscribe =&gt; File[&apos;www.conf&apos;],
</code></pre>  }<br>}<br>vim /etc/puppet/modules/lnmp/manifests/mysql.pp<br>class lnmp::mysql {<br>  package{‘mysql-server’:<pre><code>ensure  =&gt; present,
name    =&gt; &apos;mysql-server&apos;,
</code></pre>  }<br>  file{‘my.cnf’:<pre><code>ensure  =&gt; file,
source  =&gt; &apos;puppet:///modules/lnmp/my.cnf&apos;,
path    =&gt; &apos;/etc/my.cnf&apos;,
require =&gt; Package[&apos;mysql-server&apos;],
</code></pre>  }<br> service{‘mysqld’:<pre><code>ensure  =&gt; true,
enable  =&gt; true,
subscribe =&gt; File[&apos;my.cnf&apos;],
</code></pre>  }<br>}<br>vim /etc/puppet/manifests/site.pp<br>node ‘puppet-client’ {<br>include lnmp<br>}<br>4、提供服务配置文件<br>cp /root/files/{nginx.conf,www.conf,my.cnf} /etc/puppet/modules/lnmp/files/<br>5、启动puppet服务<br>[root@puppet-server modules]# puppet master –verbose –no-daemonize   #第一次启动以便观察信息Info: Creating a new SSL key for ca<br>Info: Creating a new SSL certificate request for ca<br>Info: Certificate Request fingerprint (SHA256): 7B:A9:AB:84:C0:EB:DC:83:0E:EA:8C:81:1E:25:9A:47:5C:3F:10:31:6F:F7:5C:25:BE:B7:41:3C:B8:6B:35:38…..<br>[root@puppet-client ~]# puppet agent server –server puppet-server –verbose –no-daemonize  #客户端申请证书[root@puppet-server ~]# puppet cert sign puppet-client   #服务器签署证书#稍等一会[root@puppet-client ~]# ss -tnl | egrep “80|3306|9000”LISTEN     0      128                       <em>:9000                     </em>:<em><br>LISTEN     0      50                        </em>:3306                     <em>:</em><br>LISTEN     0      128                       <em>:80                       </em>:*<br>八、总结</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/15/CentOS-6-x-Puppet/" data-id="ciwrkt72v000k88cym7bmk59r" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-前言-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/15/前言-1/" class="article-date">
  <time datetime="2016-12-15T00:23:59.000Z" itemprop="datePublished">2016-12-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/15/前言-1/">前言</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/15/前言-1/" data-id="ciwrkt75i003d88cyl9jatnmg" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-前言" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/15/前言/" class="article-date">
  <time datetime="2016-12-15T00:23:06.000Z" itemprop="datePublished">2016-12-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/15/前言/">前言</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/15/前言/" data-id="ciwrkt75k003e88cyz75su0c5" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Ubuntu-12-04-Puppet" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/15/Ubuntu-12-04-Puppet/" class="article-date">
  <time datetime="2016-12-15T00:09:45.000Z" itemprop="datePublished">2016-12-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/15/Ubuntu-12-04-Puppet/">Ubuntu 12.04 Puppet</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>前言<br>系统运维本是一件枯燥，而且重复性强的工作，不停地搞命令占据了运维人员的大量时间。Puppet通过一种集中式管理的设计，让运维变得简单可控。管理员只需要在master节点修改配置，绑定的客户端节点就会自动同步配置，让命令行也能通过配置实现。<br>第一次尝试，从安装开始。<br>目录<br>Puppet是什么？<br>Puppet服务器安装及配置<br>Puppet客户端安装及配置<br>注册puppet客户端到服务器端<br>例子：生成文件测试</p>
<ol>
<li>Puppet是什么？<br>puppet是一种Linux、Unix、windows平台的集中配置管理系统，使用自有的puppet描述语言，可管理配置文件、用户、cron任务、软件包、系统服务等。puppet把这些系统实体称之为资源，puppet的设计目标是简化对这些资源的管理以及妥善处理资源间的依赖关系。<br>puppet采用C/S星状的结构，所有的客户端和一个或几个服务器交互。每个客户端周期的（默认半个小时）向服务器发送请求，获得其最新的配置信息，保证和该配置信息同步。每个puppet客户端每半小时(可以设置)连接一次服务器端, 下载最新的配置文件,并且严格按照配置文件来配置服务器. 配置完成以后,puppet客户端可以反馈给服务器端一个消息. 如果出错,也会给服务器端反馈一个消息.<br>2台服务器的环境配置：<br>Master Server：<br>Linux Ubuntu 12.04.2 LTS 64bit<br>ip: 192.168.1.201<br>hostname: vm1<br>ruby: 1.8.7<br>Client Server：<br>Linux Ubuntu 12.04.2 LTS 64bit<br>ip: 192.168.1.202<br>hostname: vm2<br>ruby: 1.8.7</li>
<li>Puppet服务器安装及配置<br>切换到root用户<br>设置host<br>安装Puppet服务器端<br>切换到root用户<br>~ sudo -i<br>~ whoami<br>root<br>设置host<br>~ hostname vm1<br>~ hostanme<br>vm1<br>~ vi /etc/hosts<br>127.0.0.1       localhost<br>192.168.1.201   vm1<br>192.168.1.202   vm2<br>2). 安装Puppet服务器端<br>#安装并启动Puppet服务器端<br>~ apt-get install puppetmaster<br>#检查端口8140<br>~ netstat -nlt |grep 8140<br>tcp        0      0 0.0.0.0:8140            0.0.0.0:*               LISTEN<br>#查看Puppet的版本<br>~ puppet -V<br>2.7.11<br>#启动Puppet服务器<br>~  puppet master –verbose –no-daemonize<br>notice: Starting Puppet master version 2.7.11<br>3). 配置Puppet服务器，在[master]标签下，增加certname设置<br>~ vi /etc/puppet/puppet.conf<br>[master]<br>certname=vm1 #增加服务器配置<br>#重启Puppet服务器<br>~ /etc/init.d/puppetmaster restart</li>
</ol>
<ul>
<li>Restarting puppet master<br>4). 查看Puppet服务器的证书<br>~ puppet cert –list –all</li>
</ul>
<ul>
<li>“vm1” (60:0E:1D:8F:80:0B:5D:7D:F8:8B:C7:C6:DF:CF:69:43)</li>
<li>为已注册的证书<br>这样我们就完成了，服务器端的配置！接下来，继续进行客户端的配置。</li>
</ul>
<ol>
<li>Puppet客户端安装及配置<br>切换到root用户<br>~ sudo -i<br>~ whoami<br>root<br>设置host<br>~ hostname vm2<br>~ hostanme<br>vm2<br>~ vi /etc/hosts<br>127.0.0.1       localhost<br>192.168.1.201   vm1<br>192.168.1.202   vm2<br>2). 安装Puppet服务器端<br>#安装并启动Puppet客户端<br>~ apt-get install puppet<br>#查看Puppet的版本<br>~ puppet -V<br>2.7.11<br>3). 配置Puppet客户端，在[agent]标签下增加server设置<br>~ sudo vi /etc/puppet/puppet.conf<br>[agent]<br>server=vm1<br>4). 配置Puppet客户端default值，修改START设置<br>~ vi /etc/default/puppet<br>START=yes<br>设置START把no改为yes<br>重启Puppet客户端<br>~ /etc/init.d/puppet restart</li>
</ol>
<ul>
<li>Restarting puppet agent</li>
</ul>
<ol>
<li>注册puppet客户端到服务器端<br>1). 检查服务器端的证书<br>#服务器端操作<br>~ puppet cert –list –all</li>
</ol>
<ul>
<li>“vm1” (60:0E:1D:8F:80:0B:5D:7D:F8:8B:C7:C6:DF:CF:69:43)<br>2). 在服务器端(vm1)创建文件site.pp<br>#服务器端操作<br>~ sudo vi /etc/puppet/manifests/site.pp<br>node default {<br>notify { “Hey ! It works !”: }<br>}<br>3). 从客户端(vm2)向服务器端发起注册请求<br>#客户端操作<br>~ puppet agent -t<br>info: Creating a new SSL key for vm2<br>info: Caching certificate for ca<br>info: Creating a new SSL certificate request for vm2<br>info: Certificate Request fingerprint (md5): 15:45:D1:22:1B:97:6D:49:43:BC:93:D8:BB:4C:E1:99<br>Exiting; no certificate found and waitforcert is disabled<br>#如果之前生成发启过认证请求，则需要删除证书的目录<br>~ rm -rf /var/lib/puppet/ssl<br>~ puppet agent -t<br>4). 服务器端(vm1)查看客户端请求认证的列表<br>#服务器端操作<br>~ puppet cert –list<br>“vm2” (15:45:D1:22:1B:97:6D:49:43:BC:93:D8:BB:4C:E1:99)<br>5). 服务器端(vm1)接受客户端的请求<br>#服务器端操作<br>~ puppet cert –sign vm2<br>notice: Signed certificate request for vm2<br>notice: Removing file Puppet::SSL::CertificateRequest vm2 at ‘/var/lib/puppet/ssl/ca/requests/vm2.pem’<br>#可以接受所有的请求<br>~ puppet cert -s -a<br>#查看认证后，查看服务器上公钥的位置<br>~ sudo ls  /var/lib/puppet/ssl/ca/signed/<br>vm1.pem  vm2.pem<br>6). 服务器端(vm1)查看的证书列表<br>#服务器端操作<br>~ puppet cert –list –all</li>
<li>“vm1” (B7:45:28:1B:AE:53:0B:D7:38:8E:66:70:6C:B8:13:A4)</li>
<li>“vm2” (FB:64:C7:38:DA:B4:C7:0B:E6:3B:85:86:9A:F4:61:C2)<br>7). 客户端(vm2)执行服务器设置的脚本site.pp<br>#客户端操作<br>~ puppetd –test<br>info: Caching certificate for vm2<br>info: Caching certificate_revocation_list for ca<br>info: Caching catalog for vm2<br>info: Applying configuration version ‘1383527011’<br>notice: Hey ! It works !<br>notice: /Stage[main]//Node[default]/Notify[Hey ! It works !]/message: defined ‘message’ as ‘Hey ! It works !’<br>notice: Finished catalog run in 0.02 seconds<br>我们看到’Hey ! It works !’，被正常显示出来。</li>
</ul>
<ol>
<li>例子：生成文件测试<br>1). 生成文件测试，在/tmp目录下生成一个文件hello.txt。<br>在服务器端修改一个文件site.pp<br>~ vi /etc/puppet/manifests/hello.pp<br>node default {<br>notify { “Hey ! It works !”: }<br>file {<br> “/tmp/hello.txt”: content =&gt; “hello world”;<br>}<br>}<br>2). 在服务器端运行hello.pp文件<br>~ puppet apply /etc/puppet/manifests/site.pp<br>warning: Could not retrieve fact fqdn<br>warning: Host is missing hostname and/or domain: vm1<br>notice: /Stage[main]//Node[default]/File[/tmp/hello.txt]/ensure: defined content as ‘{md5}5eb63bbbe01eeed093cb22bb8f5acdc3’<br>notice: Hey ! It works !<br>notice: /Stage[main]//Node[default]/Notify[Hey ! It works !]/message: defined ‘message’ as ‘Hey ! It works !’<br>notice: Finished catalog run in 0.02 seconds<br>#检查生成的文件<br>~ cat /tmp/hello.txt<br>hello world<br>3). 在客户端同步<br>~  puppet agent –test –server=vm1<br>info: Caching catalog for vm2<br>info: Applying configuration version ‘1383528346’<br>notice: /Stage[main]//Node[default]/File[/tmp/hello.txt]/ensure: defined content as ‘{md5}5eb63bbbe01eeed093cb22bb8f5acdc3’<br>notice: Hey ! It works !<br>notice: /Stage[main]//Node[default]/Notify[Hey ! It works !]/message: defined ‘message’ as ‘Hey ! It works !’<br>notice: Finished catalog run in 0.07 seconds<br>#检查生成的文件<br>~ cat /tmp/hello.txt<br>hello world<br>这样我们就实现了第一个最简单的利用Puppet自动化运维的例子。出步尝试已经成功，接下来就像要深入研究Puppet到底能干什么，实现系统的高效运维。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/15/Ubuntu-12-04-Puppet/" data-id="ciwrkt74b001r88cy7g098sl8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-CentOS-6-x-GoAccess" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/14/CentOS-6-x-GoAccess/" class="article-date">
  <time datetime="2016-12-14T04:52:16.000Z" itemprop="datePublished">2016-12-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/14/CentOS-6-x-GoAccess/">CentOS 6.x GoAccess</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>前言<br>使用Nginx的网站可能会遇到访问流量异常、被友情检测、程序出现Bug等各种突然情况，这时大家的反应想必都是第一时间分析日志，然后发现日志有几十GB之多，又需要按照时间、错误类型或者关键字段检索信息时会不会有种醍醐灌顶、菊花一紧的错觉。文中介绍的方法不管是GoAccess还是sed/awk虽然可以解决一时的问题但未必能够治本，也许ELK(Logstash+ElasticSearch+Kibana)对我们大多数人来说是更合理的集中化日志管理解决方案。<br>日志固然重要，但努力建设适合业务发展的集中化日志管理平台才是基础核心<br>更新历史<br>2015年08月31日 - 增加Nginx日志按时间分割<br>2015年07月16日 - 初稿<br>阅读原文 - <a href="http://wsgzao.github.io/post/goaccess/" target="_blank" rel="external">http://wsgzao.github.io/post/goaccess/</a><br>扩展阅读<br>GoAccess - <a href="http://goaccess.io/" target="_blank" rel="external">http://goaccess.io/</a><br>用GoAccess分析Nginx的日志 - <a href="http://www.fancycoding.com/log-analyse-using-goaccess/" target="_blank" rel="external">http://www.fancycoding.com/log-analyse-using-goaccess/</a><br>sed 简明教程 - <a href="http://coolshell.cn/articles/9104.html" target="_blank" rel="external">http://coolshell.cn/articles/9104.html</a><br>AWK 简明教程 - <a href="http://coolshell.cn/articles/9070.html" target="_blank" rel="external">http://coolshell.cn/articles/9070.html</a><br>LTMP索引 - <a href="http://wsgzao.github.io/index/#LTMP" target="_blank" rel="external">http://wsgzao.github.io/index/#LTMP</a><br>安装GoAccess<br>各平台都有灰常简单的部署方案 - <a href="http://goaccess.io/download" target="_blank" rel="external">http://goaccess.io/download</a><br>wget <a href="http://tar.goaccess.io/goaccess-0.9.2.tar.gz" target="_blank" rel="external">http://tar.goaccess.io/goaccess-0.9.2.tar.gz</a><br>tar -xzvf goaccess-0.9.2.tar.gz<br>cd goaccess-0.9.2/<br>./configure –enable-utf8<br>make<br>make install<br>使用方式<br>更多常见问题请参考官方FAQ - <a href="http://goaccess.io/faq" target="_blank" rel="external">http://goaccess.io/faq</a></p>
<p>#直接打开<br>goaccess -f access.log</p>
<p>#选择日志格式<br>NCSA Combined Log Format</p>
<p>#剩下的操作都蛮简单的，参考扩展阅读和官方文档吧</p>
<p>#导出HTML报告会遇到的问题<br>goaccess -f time_access.log -a &gt; report.html</p>
<p>GoAccess - version 0.9.2 - Jul 15 2015 16:23:20<br>Config file: /usr/local/etc/goaccess.conf</p>
<p>Fatal error has occurred<br>Error occured at: src/parser.c - verify_formats - 1691<br>No time format was found on your conf file.</p>
<p>#添加配置文件<br>vi ~/.goaccessrc</p>
<p>time-format %T<br>date-format %d/%b/%Y<br>log-format %h %^[%d:%t %^] “%r” %s %b “%R” “%u”</p>
<p>#重新指定配置文件后执行<br>goaccess -f time_access.log -p ~/.goaccessrc -a &gt; report.html<br>使用bash/sed/awk手动查找Nginx日志<br>更多技巧可以参考扩展阅读，Python的处理效率或者更优</p>
<p>#按日期查找时间段<br>sed -n “/30\/Aug\/2015:00:00:01/,/30\/Aug\/2015:23:59:59/“p access.log &gt; time_access.log</p>
<p>#查找504错误的页面和数量<br>awk ‘($9 ~ /504/)’ time_access.log | awk ‘{print $7}’ | sort | uniq -c | sort -rn &gt; 504.log</p>
<p>#查找访问最多的20个IP及访问次数<br>awk ‘{print $1}’ time_access.log | sort | uniq -c | sort -n -k 1 -r | head -n 20 &gt; top.log<br>Nginx日志按时间分割<br>这个脚本可以作为通用模板，其它业务需求也可以参照</p>
<p>#增加自定义脚本<br>vi nginx_log.sh</p>
<p>#!/bin/bash</p>
<p>#设置crontab -e为每日凌晨3点</p>
<p>#0 3 <em> </em> * /root/OMCS/script/nginx_log.sh</p>
<p>for ngix_i in <code>ls /app/local</code><br>do</p>
<pre><code>#设置临时变量
nginx_dir=`basename ${ngix_i}`
if ( echo &quot;$nginx_dir&quot;|grep &quot;nginx&quot; &gt; /dev/null ); then
     # echo $nginx_dir
     #设置日志文件存放目录
     logs_path=&quot;/app/local/$nginx_dir/logs/&quot;
     #设置备份日志存放目录
     logs_bak=&quot;/app/local/$nginx_dir/logs/bak/&quot;
     #设置pid文件
     pid_path=&quot;/app/local/$nginx_dir/logs/nginx.pid&quot;

     #判断目录是否存在
     if  [ ! -d  &quot;$logs_path&quot; ]; then
          continue
     fi
     #判断文件是否存在
     if  [ ! -e  &quot;$pid_path&quot; ]; then
          continue
     fi

     #判断目录是否存在
     if  [ ! -d  &quot;$logs_bak&quot; ]; then
          mkdir -p &quot;$logs_bak&quot;
     fi

     cd ${logs_path}
     logfiles=(`ls *.log`)

     array_i=0
     #迁移日志循环模块
     for i in ${logfiles[@]};
     do
          #设置临时变量
          j=`basename ${i}`
          #重命名并迁移日志文件
          baklogname=${j}_$(date -d &quot;yesterday&quot; +&quot;%Y%m%d%H%M%S&quot;)
          baklognames[$array_i]=$baklogname
          mv ${i} ${logs_bak}${baklogname}
          array_i=`expr $array_i + 1`
     done

     #向nginx主进程发信号重新打开日志
     kill -USR1 `cat ${pid_path}`

     cd ${logs_bak}
     #压缩日志循环模块
     for i in ${baklognames[@]};
     do
          #压缩并删除原日志
          tar -zcvf ${i}.tar.gz ${i} --remove-files &gt; /dev/null 2&gt;&amp;1
     done

     #清理7天前的日志
     find ${logs_bak} -name &apos;*&apos;  -mtime +90 | xargs rm -rf {}

fi
</code></pre><p>done</p>
<p>#增加执行权限<br>chmod u+x nginx_log.sh</p>
<p>#设置crontab -e为每日凌晨3点<br>crontab -e</p>
<p>0 3 <em> </em> * /root/OMCS/script/nginx_log.sh</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/14/CentOS-6-x-GoAccess/" data-id="ciwrkt72m000d88cy57kq7dt0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-CentOS-6-x-Logrotate" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/14/CentOS-6-x-Logrotate/" class="article-date">
  <time datetime="2016-12-14T04:51:19.000Z" itemprop="datePublished">2016-12-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/14/CentOS-6-x-Logrotate/">CentOS 6.x Logrotate</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>日志文件包含系统内部执行情况的有用信息。在排除故障或服务器性能分析时往往需要检查日志。对于繁忙的服务器，日志文件可能会在短时间内变得非常大。这将成为一个问题，因为服务器会很快耗尽存储空间。此外，操作一个非常大的日志文件往往会非常棘手。<br>logrotate 是可以自动转储、压缩和删除旧日志文件的一个非常有用的工具。例如，你可以设置logrotate将日志文件 /var/log/foo的每30天转储一次，并且删除超过6个月的记录。一旦配置完成，logrotate可以完全自动化操作不需要进行人工交互<br>在主要的Linux发行版中logrotate包通常是默认安装的。如果由于某种原因，logrotate的不存在，您可以使用apt-get或者yum的命令来安装它。<br>Debian或者Ubuntu</p>
<h1 id="apt-get-install-logrotate-cron"><a href="#apt-get-install-logrotate-cron" class="headerlink" title="apt-get install logrotate cron"></a>apt-get install logrotate cron</h1><p>Fedora, CentOS或者RHEL</p>
<h1 id="yum-install-logrotate-crontabs"><a href="#yum-install-logrotate-crontabs" class="headerlink" title="yum install logrotate crontabs"></a>yum install logrotate crontabs</h1><p>logrotate的配置文件是/etc/logrotate.conf，一般不需要修改。可以在/etc/logrotate.d/目录下放入单独的配置文件定义本文档中需要的功能。<br>示例一<br>在第一个例子中，我们将创建一个10 MB的日志文件/var/log/log-file。我们将看到我们如何使用logrotate来管理这个日志文件。<br>我们首先创建一个10M的日志文件，并用随机位来填充它。</p>
<h1 id="touch-var-log-log-file-head-c-10M-lt-dev-urandom-gt-var-log-log-file"><a href="#touch-var-log-log-file-head-c-10M-lt-dev-urandom-gt-var-log-log-file" class="headerlink" title="touch /var/log/log-file# head -c 10M &lt; /dev/urandom &gt; /var/log/log-file"></a>touch /var/log/log-file# head -c 10M &lt; /dev/urandom &gt; /var/log/log-file</h1><p>日志文件已经准备就绪，我们将配置logrotate转储这个日志文件。让我们开始创建转储所需要的logrotate配置文件。</p>
<h1 id="vim-etc-logrotate-d-log-file"><a href="#vim-etc-logrotate-d-log-file" class="headerlink" title="vim /etc/logrotate.d/log-file"></a>vim /etc/logrotate.d/log-file</h1><p>/var/log/log-file {<br>    monthly<br>    rotate<br>5<br>    compress<br>    delaycompress<br>    missingok<br>    notifempty<br>    create<br>644<br>root root<br>    postrotate<br>/usr/bin/killall -<br>HUP rsyslogd<br>    endscript<br>}<br>其中：<br>monthly：每月转储日志文件。其他可能的值是’daily’, ‘weekly’, ‘yearly’。<br>rotate 5：同一时间保存5个归档日志。对于第6个归档，最早的归档文件将被删除。<br>compress：转储完成后，转储的日志将使用gzip压缩。<br>delaycompress：需要与compress选项一起使用，delaycompress参数指示logrotate的不对最新的归档进行压缩。压缩将在下一个转储周期来进行。如果您需要访问的最新备份的存档，这是很有用的。<br>missingok：在转储过程中任何错误都会被忽略，例如，”未找到文件”。<br>notifempty：如果日志文件是空的将不会执行转储。<br>create 644 root root：logrotate归档时可以重命名原始日志文件然后创建一个新的日志文件并赋予与指定的权限。<br>postrotate/endscript：所有其他操作完成后会执行postrotate和endscript间定义的命令。在上面的例子中，处理rsyslogd将重新读取其配置后继续运行。<br>上面的模板是通用的，配置参数可以根据您的要求各不相同。不是所有的参数可能是必要的。<br>示例二<br>在这个例子中，我们想要只在日志文件大小增长超过50MB时转储日志文件。</p>
<h1 id="vim-etc-logrotate-d-log-file-1"><a href="#vim-etc-logrotate-d-log-file-1" class="headerlink" title="vim /etc/logrotate.d/log-file"></a>vim /etc/logrotate.d/log-file</h1><p>/var/log/log-file {    size=50M    rotate 5    create 644<br>root root<br>    postrotate<br>/usr/bin/killall -<br>HUP rsyslogd<br>    endscript<br>}<br>示例三<br>我们希望旧的日志文件根据归档日期进行命名，这可以通过添加dateext参数来实现。</p>
<h1 id="vim-etc-logrotate-d-log-file-2"><a href="#vim-etc-logrotate-d-log-file-2" class="headerlink" title="vim /etc/logrotate.d/log-file"></a>vim /etc/logrotate.d/log-file</h1><p>/var/log/log-file {    size=50M    rotate 5    create 644<br>root root<br>    postrotate<br>/usr/bin/killall -<br>HUP rsyslogd<br>    endscript<br>}</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/14/CentOS-6-x-Logrotate/" data-id="ciwrkt72p000g88cykozgxyh1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-CentOS-6-x-Docker-Swarm-Etcd-Cluster" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/14/CentOS-6-x-Docker-Swarm-Etcd-Cluster/" class="article-date">
  <time datetime="2016-12-14T04:50:08.000Z" itemprop="datePublished">2016-12-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/14/CentOS-6-x-Docker-Swarm-Etcd-Cluster/">CentOS 6.x Docker + Swarm + Etcd Cluster</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="https://docs.docker.com/engine/installation/linux/centos/" target="_blank" rel="external">https://docs.docker.com/engine/installation/linux/centos/</a></p>
<p>安装Swarm集群<br>环境信息<br>服务器:<br>192.168.99.100 centos-node1<br>192.168.99.101 centos-node2<br>192.168.99.102 centos-node3<br>集群信息:<br>etc服务器: 192.168.99.100:2379<br>swarm manage: 192.168.99.101:3376<br>swarm-node1: 192.168.99.100:2375<br>swarm-node2: 192.168.99.101:2375<br>swarm-node3: 192.168.99.102:2375<br>准备<br>在所有的机器上安装dokcer<br>在centos-node1 上docker pull ystyle/etcd (官方的下载不了,自己做了个一样的)<br>在所有机器上dokcer pull swarm<br>以上三步可以用docker-machine完成<br>开放所有机器的2375端口, centos-node1的2379端口,centos-node2的3376端口<br>安装etcd k-v数据库<br>在centos-node1上执行:</p>
<h1 id="设置当前host的ip"><a href="#设置当前host的ip" class="headerlink" title="设置当前host的ip"></a>设置当前host的ip</h1><p>export HOSTIP=192.168.99.100</p>
<h1 id="启动etcd-k-v服务器"><a href="#启动etcd-k-v服务器" class="headerlink" title="启动etcd k-v服务器"></a>启动etcd <code>k-v</code>服务器</h1><p>docker run -d -v /etc/ssl/certs:/etc/ssl/certs -p 4001:4001 -p 2380:2380 -p 2379:2379<br> –name etcd ystyle/etcd<br> -name etcd0<br> -advertise-client-urls <a href="http://${HOSTIP}:2379,http://${HOSTIP}:4001" target="_blank" rel="external">http://${HOSTIP}:2379,http://${HOSTIP}:4001</a><br> -listen-client-urls <a href="http://0.0.0.0:2379,http://0.0.0.0:4001" target="_blank" rel="external">http://0.0.0.0:2379,http://0.0.0.0:4001</a><br> -initial-advertise-peer-urls <a href="http://${HOSTIP}:2380" target="_blank" rel="external">http://${HOSTIP}:2380</a><br> -listen-peer-urls <a href="http://0.0.0.0:2380" target="_blank" rel="external">http://0.0.0.0:2380</a><br> -initial-cluster-token etcd-cluster-1<br> -initial-cluster etcd0=<a href="http://${HOSTIP}:2380" target="_blank" rel="external">http://${HOSTIP}:2380</a><br> -initial-cluster-state new<br>加入集群<br>在centos-node1执行:<br>docker run -d swarm join –addr=192.168.99.100:2375 etcd://192.168.99.100:2379/swarm<br>在centos-node2执行:<br>docker run -d swarm join –addr=192.168.99.101:2375 etcd://192.168.99.100:2379/swarm<br>在centos-node3执行:<br>docker run -d swarm join –addr=192.168.99.102:2375 etcd://192.168.99.100:2379/swarm<br>启动swarm manage<br>在centos-node2上执行</p>
<h1 id="启动swarm-manage"><a href="#启动swarm-manage" class="headerlink" title="启动swarm manage"></a>启动swarm manage</h1><p>docker run -d -p 3376:3376 -t<br> swarm manage<br>-H 0.0.0.0:3376<br>etcd://192.168.99.100:2379/swarm</p>
<h1 id="检查swarm节点列表"><a href="#检查swarm节点列表" class="headerlink" title="检查swarm节点列表"></a>检查swarm节点列表</h1><p>docker run –rm swarm list etcd://192.168.99.100:2379/swarm</p>
<h1 id="查看swarm集群信息"><a href="#查看swarm集群信息" class="headerlink" title="查看swarm集群信息"></a>查看swarm集群信息</h1><p>export DOCKER_HOST=192.168.99.101:3376<br>docker info</p>
<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>docker run –rm -p 8080:80 nginx:alpine<br>docker ps -a</p>
<h1 id="查看nginx安装到哪台机器上了"><a href="#查看nginx安装到哪台机器上了" class="headerlink" title="查看nginx安装到哪台机器上了"></a>查看nginx安装到哪台机器上了</h1><p>curl -L <a href="http://nginx_host:8080" target="_blank" rel="external">http://nginx_host:8080</a><br>记录<br>如果docker info 出现Error: ID duplicated.删掉/etc/docker/key.json文件(我的虚拟机是直接复制出来的)<br>参考资料<br><a href="https://docs.docker.com/v1.5/swarm/discovery/#using-etcd" target="_blank" rel="external">https://docs.docker.com/v1.5/swarm/discovery/#using-etcd</a><br><a href="https://docs.docker.com/engine/userguide/networking/get-started-overlay/" target="_blank" rel="external">https://docs.docker.com/engine/userguide/networking/get-started-overlay/</a><br><a href="https://github.com/docker/swarm" target="_blank" rel="external">https://github.com/docker/swarm</a><br><a href="https://github.com/coreos/etcd" target="_blank" rel="external">https://github.com/coreos/etcd</a><br><a href="https://docs.docker.com/engine/installation/linux/centos/" target="_blank" rel="external">https://docs.docker.com/engine/installation/linux/centos/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/14/CentOS-6-x-Docker-Swarm-Etcd-Cluster/" data-id="ciwrkt72h000888cydk4an56l" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/5/">&laquo; __('prev')</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><a class="extend next" rel="next" href="/page/7/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/12/15/NGINX日志切割/">NGINX日志切割</a>
          </li>
        
          <li>
            <a href="/2016/12/15/CentOS-6-x-安装SVN/">CentOS 6.x 安装SVN</a>
          </li>
        
          <li>
            <a href="/2016/12/15/CentOS-7-x-git/">CentOS 7.x git</a>
          </li>
        
          <li>
            <a href="/2016/12/15/开源资源/">开源资源</a>
          </li>
        
          <li>
            <a href="/2016/12/15/开源软件/">开源软件</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 JinYan<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>